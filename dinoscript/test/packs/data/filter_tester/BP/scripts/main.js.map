{
  "version": 3,
  "sources": ["../../data/dinoscript/mod.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/Vec3.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/Logging.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/ChatColor.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/ColorJSON.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/Timings.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/ProfilingUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/Cache.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/polyfill/Polyfill.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/polyfill/PlayerPolyfill.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/VersionUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/JobUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/BlockUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/scheduling/PulseScheduler.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/scheduling/TaskPulseScheduler.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/scheduling/UniquePulseScheduler.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/scheduling/EntityPulseScheduler.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/scheduling/PlayerPulseScheduler.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/CommandUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/VariableSender.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/vanilla/VanillaBlockTags.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/vanilla/VanillaItemTags.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/vanilla/TimeOfDay.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/DirectionUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/ColorUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/EntitySaver.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/ItemUtils.ts", "../../../../../../../../../.cache/deno/npm/registry.npmjs.org/@bedrock-oss/bedrock-boost/1.3.1/src/utils/EntityUtils.ts"],
  "sourcesContent": ["import { world } from \"@minecraft/server\";\nimport { Logger } from \"@bedrock-oss/bedrock-boost\";\n\nconst log = Logger.getLogger(\"Dinoscript\");\n\nworld.afterEvents.playerPlaceBlock.subscribe((event) => {\n    log.info(\"Placed\", event.block.typeId);\n});\n", "import { Vector3, Direction, Vector2 } from \"@minecraft/server\";\r\nimport { Logger } from \"./Logging\";\r\n\r\ntype VectorLike = Vector3 | Vec3 | Direction | number[] | number;\r\n\r\nexport default class Vec3 implements Vector3 {\r\n  private static readonly log = Logger.getLogger(\r\n    \"vec3\",\r\n    \"vec3\",\r\n    \"bedrock-boost\"\r\n  );\r\n  /**\r\n   * Zero vector\r\n   */\r\n  public static readonly Zero = new Vec3(0, 0, 0);\r\n  /**\r\n   * Down vector, negative towards Y\r\n   */\r\n  public static readonly Down = new Vec3(Direction.Down);\r\n  /**\r\n   * Up vector, positive towards Y\r\n   */\r\n  public static readonly Up = new Vec3(Direction.Up);\r\n  /**\r\n   * North vector, negative towards Z\r\n   */\r\n  public static readonly North = new Vec3(Direction.North);\r\n  /**\r\n   * South vector, positive towards Z\r\n   */\r\n  public static readonly South = new Vec3(Direction.South);\r\n  /**\r\n   * East vector, positive towards X\r\n   */\r\n  public static readonly East = new Vec3(Direction.East);\r\n  /**\r\n   * West vector, negative towards X\r\n   */\r\n  public static readonly West = new Vec3(Direction.West);\r\n\r\n  readonly x: number;\r\n  readonly y: number;\r\n  readonly z: number;\r\n  constructor(x: number, y: number, z: number);\r\n  constructor(x: Vec3);\r\n  constructor(x: Vector3);\r\n  constructor(x: Direction);\r\n  constructor(x: number[]);\r\n  constructor(x: VectorLike, y?: number, z?: number) {\r\n    if (x === Direction.Down) {\r\n      this.x = 0;\r\n      this.y = -1;\r\n      this.z = 0;\r\n    } else if (x === Direction.Up) {\r\n      this.x = 0;\r\n      this.y = 1;\r\n      this.z = 0;\r\n    } else if (x === Direction.North) {\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.z = -1;\r\n    } else if (x === Direction.South) {\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.z = 1;\r\n    } else if (x === Direction.East) {\r\n      this.x = 1;\r\n      this.y = 0;\r\n      this.z = 0;\r\n    } else if (x === Direction.West) {\r\n      this.x = -1;\r\n      this.y = 0;\r\n      this.z = 0;\r\n    } else if (typeof x === \"number\") {\r\n      this.x = x;\r\n      this.y = y!;\r\n      this.z = z!;\r\n    } else if (Array.isArray(x)) {\r\n      this.x = x[0];\r\n      this.y = x[1];\r\n      this.z = x[2];\r\n    } else if (x instanceof Vec3) {\r\n      this.x = x.x;\r\n      this.y = x.y;\r\n      this.z = x.z;\r\n    } else {\r\n      if (\r\n        !x ||\r\n        (!x.x && x.x !== 0) ||\r\n        (!x.y && x.y !== 0) ||\r\n        (!x.z && x.z !== 0)\r\n      ) {\r\n        Vec3.log.error(new Error(\"Invalid vector\"), x);\r\n        throw new Error(\"Invalid vector\");\r\n      }\r\n      this.x = x.x;\r\n      this.y = x.y;\r\n      this.z = x.z;\r\n    }\r\n  }\r\n  /**\r\n   * Creates a new vector from the given values.\r\n   */\r\n  static from(x: number, y: number, z: number): Vec3;\r\n  static from(x: Vec3): Vec3;\r\n  static from(x: Vector3): Vec3;\r\n  static from(x: Direction): Vec3;\r\n  static from(x: number[]): Vec3;\r\n  static from(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    if (x instanceof Vec3) return x;\r\n    if (typeof x === \"number\" && y !== undefined && z !== undefined) {\r\n      return new Vec3(x, y, z);\r\n    }\r\n    if (Array.isArray(x)) {\r\n      return new Vec3(x);\r\n    }\r\n    if (x === Direction.Down) return Vec3.Down;\r\n    if (x === Direction.Up) return Vec3.Up;\r\n    if (x === Direction.North) return Vec3.North;\r\n    if (x === Direction.South) return Vec3.South;\r\n    if (x === Direction.East) return Vec3.East;\r\n    if (x === Direction.West) return Vec3.West;\r\n    if (\r\n      !x ||\r\n      (!(x as any).x && (x as any).x !== 0) ||\r\n      (!(x as any).y && (x as any).y !== 0) ||\r\n      (!(x as any).z && (x as any).z !== 0)\r\n    ) {\r\n      Vec3.log.error(new Error(\"Invalid arguments\"), x, y, z);\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    return new Vec3(\r\n      (x as any).x as number,\r\n      (x as any).y as number,\r\n      (x as any).z as number\r\n    );\r\n  }\r\n  private static _from(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    if (x instanceof Vec3) return x;\r\n    if (typeof x === \"number\" && y !== undefined && z !== undefined) {\r\n      return new Vec3(x, y, z);\r\n    }\r\n    if (Array.isArray(x)) {\r\n      return new Vec3(x);\r\n    }\r\n    if (x === Direction.Down) return Vec3.Down;\r\n    if (x === Direction.Up) return Vec3.Up;\r\n    if (x === Direction.North) return Vec3.North;\r\n    if (x === Direction.South) return Vec3.South;\r\n    if (x === Direction.East) return Vec3.East;\r\n    if (x === Direction.West) return Vec3.West;\r\n    if (\r\n      !x ||\r\n      (!(x as any).x && (x as any).x !== 0) ||\r\n      (!(x as any).y && (x as any).y !== 0) ||\r\n      (!(x as any).z && (x as any).z !== 0)\r\n    ) {\r\n      Vec3.log.error(new Error(\"Invalid arguments\"), x, y, z);\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    return new Vec3(\r\n      (x as any).x as number,\r\n      (x as any).y as number,\r\n      (x as any).z as number\r\n    );\r\n  }\r\n  /**\r\n   * Creates a copy of the current vector.\r\n   *\r\n   * @returns A new vector with the same values as the current vector.\r\n   */\r\n  copy(): Vec3 {\r\n    return new Vec3(this.x, this.y, this.z);\r\n  }\r\n  /**\r\n   * Creates a new direction vector from yaw and pitch values.\r\n   *\r\n   * @param rotation - The yaw and pitch values in degrees.\r\n   * @returns A new vector representing the direction.\r\n   * @deprecated Use fromRotation() instead. This method returns inverted values and will be removed in the future.\r\n   */\r\n  static fromYawPitch(rotation: Vector2): Vec3;\r\n  /**\r\n   * Creates a new direction vector from yaw and pitch values.\r\n   *\r\n   * @param yaw - The yaw value in degrees.\r\n   * @param pitch - The pitch value in degrees.\r\n   * @returns A new vector representing the direction.\r\n   * @deprecated Use fromRotation() instead. This method returns inverted values and will be removed in the future.\r\n   */\r\n  static fromYawPitch(yaw: number, pitch: number): Vec3;\r\n  static fromYawPitch(yawOrRotation: number | Vector2, pitch?: number): Vec3 {\r\n    let yaw: number;\r\n    if (typeof yawOrRotation === \"number\") {\r\n      yaw = yawOrRotation as number;\r\n      pitch = pitch!;\r\n    } else {\r\n      yaw = yawOrRotation.y;\r\n      pitch = yawOrRotation.x;\r\n    }\r\n    // Convert degrees to radians\r\n    const psi = yaw * (Math.PI / 180);\r\n    const theta = pitch * (Math.PI / 180);\r\n\r\n    const x = Math.cos(theta) * Math.sin(psi);\r\n    const y = Math.sin(theta);\r\n    const z = Math.cos(theta) * Math.cos(psi);\r\n    return new Vec3(x, y, z);\r\n  }\r\n\r\n  /**\r\n   * Creates a new direction vector from yaw and pitch values.\r\n   *\r\n   * @param rotation - The yaw and pitch values in degrees.\r\n   * @returns A new vector representing the direction.\r\n   */\r\n  static fromRotation(rotation: Vector2): Vec3;\r\n  /**\r\n   * Creates a new direction vector from yaw and pitch values.\r\n   *\r\n   * @param yaw - The yaw value in degrees.\r\n   * @param pitch - The pitch value in degrees.\r\n   * @returns A new vector representing the direction.\r\n   */\r\n  static fromRotation(yaw: number, pitch: number): Vec3;\r\n  static fromRotation(yawOrRotation: number | Vector2, pitch?: number): Vec3 {\r\n    let yaw: number;\r\n    if (typeof yawOrRotation === \"number\") {\r\n      yaw = yawOrRotation as number;\r\n      pitch = pitch!;\r\n    } else {\r\n      yaw = yawOrRotation.y;\r\n      pitch = yawOrRotation.x;\r\n    }\r\n    // Convert degrees to radians\r\n    const psi = yaw * (Math.PI / 180);\r\n    const theta = pitch * (Math.PI / 180);\r\n\r\n    const x = -Math.cos(theta) * Math.sin(psi);\r\n    const y = -Math.sin(theta);\r\n    const z = Math.cos(theta) * Math.cos(psi);\r\n    return new Vec3(x, y, z);\r\n  }\r\n\r\n  /**\r\n   * Converts the normal vector to yaw and pitch values.\r\n   *\r\n   * @returns A Vector2 containing the yaw and pitch values.\r\n   * @deprecated Use toRotation() instead. This method returns inverted values and will be removed in the future.\r\n   */\r\n  toYawPitch(): Vector2 {\r\n    if (this.isZero()) {\r\n      Vec3.log.error(\r\n        new Error(\"Cannot convert zero-length vector to direction\")\r\n      );\r\n      throw new Error(\"Cannot convert zero-length vector to direction\");\r\n    }\r\n    const direction = this.normalize();\r\n    const yaw = Math.atan2(direction.x, direction.z) * (180 / Math.PI);\r\n    const pitch = Math.asin(direction.y) * (180 / Math.PI);\r\n    return {\r\n      x: pitch,\r\n      y: yaw,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Converts the normal vector to yaw and pitch values.\r\n   *\r\n   * @returns A Vector2 containing the yaw and pitch values.\r\n   */\r\n  toRotation(): Vector2 {\r\n    if (this.isZero()) {\r\n      Vec3.log.error(\r\n        new Error(\"Cannot convert zero-length vector to direction\")\r\n      );\r\n      throw new Error(\"Cannot convert zero-length vector to direction\");\r\n    }\r\n    const direction = this.normalize();\r\n    const yaw = -Math.atan2(direction.x, direction.z) * (180 / Math.PI);\r\n    const pitch = Math.asin(-direction.y) * (180 / Math.PI);\r\n    return {\r\n      x: pitch,\r\n      y: yaw,\r\n    };\r\n  }\r\n  /**\r\n   * Adds three numbers to the current vector.\r\n   *\r\n   * @param x - The x component to be added.\r\n   * @param y - The y component to be added.\r\n   * @param z - The z component to be added.\r\n   * @returns The updated vector after addition.\r\n   */\r\n  add(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Adds another Vec3 to the current vector.\r\n   *\r\n   * @param x - The Vec3 to be added.\r\n   * @returns The updated vector after addition.\r\n   */\r\n  add(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Adds another Vector3 to the current vector.\r\n   *\r\n   * @param x - The Vector3 to be added.\r\n   * @returns The updated vector after addition.\r\n   */\r\n  add(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Adds a Direction to the current vector.\r\n   *\r\n   * @param x - The Direction to be added.\r\n   * @returns The updated vector after addition.\r\n   */\r\n  add(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Adds an array of numbers to the current vector.\r\n   *\r\n   * @param x - The array of numbers to be added.\r\n   * @returns The updated vector after addition.\r\n   */\r\n  add(x: number[]): Vec3;\r\n\r\n  add(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return Vec3.from(v.x + this.x, v.y + this.y, v.z + this.z);\r\n  }\r\n\r\n  /**\r\n   * Subtracts three numbers from the current vector.\r\n   *\r\n   * @param x - The x component to be subtracted.\r\n   * @param y - The y component to be subtracted.\r\n   * @param z - The z component to be subtracted.\r\n   * @returns The updated vector after subtraction.\r\n   */\r\n  subtract(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Subtracts another Vec3 from the current vector.\r\n   *\r\n   * @param x - The Vec3 to be subtracted.\r\n   * @returns The updated vector after subtraction.\r\n   */\r\n  subtract(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Subtracts another Vector3 from the current vector.\r\n   *\r\n   * @param x - The Vector3 to be subtracted.\r\n   * @returns The updated vector after subtraction.\r\n   */\r\n  subtract(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Subtracts a Direction from the current vector.\r\n   *\r\n   * @param x - The Direction to be subtracted.\r\n   * @returns The updated vector after subtraction.\r\n   */\r\n  subtract(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Subtracts an array of numbers from the current vector.\r\n   *\r\n   * @param x - The array of numbers to be subtracted.\r\n   * @returns The updated vector after subtraction.\r\n   */\r\n  subtract(x: number[]): Vec3;\r\n\r\n  subtract(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return Vec3.from(this.x - v.x, this.y - v.y, this.z - v.z);\r\n  }\r\n\r\n  /**\r\n   * Multiplies the current vector by three numbers.\r\n   *\r\n   * @param x - The multiplier for the x component.\r\n   * @param y - The multiplier for the y component.\r\n   * @param z - The multiplier for the z component.\r\n   * @returns The updated vector after multiplication.\r\n   */\r\n  multiply(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Multiplies the current vector by another Vec3.\r\n   *\r\n   * @param x - The Vec3 multiplier.\r\n   * @returns The updated vector after multiplication.\r\n   */\r\n  multiply(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Multiplies the current vector by another Vector3.\r\n   *\r\n   * @param x - The Vector3 multiplier.\r\n   * @returns The updated vector after multiplication.\r\n   */\r\n  multiply(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Multiplies the current vector by a Direction.\r\n   *\r\n   * @param x - The Direction multiplier.\r\n   * @returns The updated vector after multiplication.\r\n   */\r\n  multiply(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Multiplies the current vector by an array of numbers.\r\n   *\r\n   * @param x - The array multiplier.\r\n   * @returns The updated vector after multiplication.\r\n   */\r\n  multiply(x: number[]): Vec3;\r\n\r\n  /**\r\n   * Multiplies the current vector by a scalar.\r\n   *\r\n   * @param x - The scalar multiplier.\r\n   * @returns The updated vector after multiplication.\r\n   */\r\n  multiply(x: number): Vec3;\r\n\r\n  multiply(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    if (typeof x === \"number\" && y === undefined && z === undefined) {\r\n      return Vec3.from(this.x * x, this.y * x, this.z * x);\r\n    }\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return Vec3.from(v.x * this.x, v.y * this.y, v.z * this.z);\r\n  }\r\n\r\n  /**\r\n   * Scales the current vector by a scalar.\r\n   *\r\n   * @param scalar - The scalar to scale the vector by.\r\n   * @returns The updated vector after scaling.\r\n   */\r\n  scale(scalar: number): Vec3 {\r\n    return Vec3.from(this.x * scalar, this.y * scalar, this.z * scalar);\r\n  }\r\n\r\n  /**\r\n   * Divides the current vector by three numbers.\r\n   *\r\n   * @param x - The divisor for the x component.\r\n   * @param y - The divisor for the y component.\r\n   * @param z - The divisor for the z component.\r\n   * @returns The updated vector after division.\r\n   */\r\n  divide(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Divides the current vector by another Vec3.\r\n   *\r\n   * @param x - The Vec3 divisor.\r\n   * @returns The updated vector after division.\r\n   */\r\n  divide(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Divides the current vector by another Vector3.\r\n   *\r\n   * @param x - The Vector3 divisor.\r\n   * @returns The updated vector after division.\r\n   */\r\n  divide(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Divides the current vector by a Direction.\r\n   *\r\n   * @param x - The Direction divisor.\r\n   * @returns The updated vector after division.\r\n   */\r\n  divide(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Divides the current vector by an array of numbers.\r\n   *\r\n   * @param x - The array divisor.\r\n   * @returns The updated vector after division.\r\n   */\r\n  divide(x: number[]): Vec3;\r\n\r\n  /**\r\n   * Divides the current vector by a scalar.\r\n   *\r\n   * @param x - The scalar divisor.\r\n   * @returns The updated vector after division.\r\n   */\r\n  divide(x: number): Vec3;\r\n\r\n  divide(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    if (typeof x === \"number\" && y === undefined && z === undefined) {\r\n      if (x === 0) throw new Error(\"Cannot divide by zero\");\r\n      return Vec3.from(this.x / x, this.y / x, this.z / x);\r\n    }\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    if (v.x === 0 || v.y === 0 || v.z === 0)\r\n      throw new Error(\"Cannot divide by zero\");\r\n    return Vec3.from(this.x / v.x, this.y / v.y, this.z / v.z);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the vector to have a length (magnitude) of 1.\r\n   * Normalized vectors are often used as a direction vectors.\r\n   *\r\n   * @returns The normalized vector.\r\n   */\r\n  normalize(): Vec3 {\r\n    if (this.isZero()) {\r\n      Vec3.log.error(new Error(\"Cannot normalize zero-length vector\"));\r\n      throw new Error(\"Cannot normalize zero-length vector\");\r\n    }\r\n    const len = this.length();\r\n    return Vec3.from(this.x / len, this.y / len, this.z / len);\r\n  }\r\n  /**\r\n   * Computes the length (magnitude) of the vector.\r\n   *\r\n   * @returns The length of the vector.\r\n   */\r\n  length(): number {\r\n    return Math.hypot(this.x, this.y, this.z);\r\n  }\r\n  /**\r\n   * Computes the squared length of the vector.\r\n   * This is faster than computing the actual length and can be useful for comparison purposes.\r\n   *\r\n   * @returns The squared length of the vector.\r\n   */\r\n  lengthSquared(): number {\r\n    return this.x * this.x + this.y * this.y + this.z * this.z;\r\n  }\r\n  /**\r\n   * Computes the cross product of the current vector with three numbers.\r\n   *\r\n   * A cross product is a vector that is perpendicular to both vectors.\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @returns A new vector representing the cross product.\r\n   */\r\n  cross(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Computes the cross product of the current vector with another Vec3.\r\n   *\r\n   * A cross product is a vector that is perpendicular to both vectors.\r\n   *\r\n   * @param x - The Vec3 to be crossed.\r\n   * @returns A new vector representing the cross product.\r\n   */\r\n  cross(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Computes the cross product of the current vector with another Vector3.\r\n   *\r\n   * A cross product is a vector that is perpendicular to both vectors.\r\n   *\r\n   * @param x - The Vector3 to be crossed.\r\n   * @returns A new vector representing the cross product.\r\n   */\r\n  cross(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Computes the cross product of the current vector with a Direction.\r\n   *\r\n   * A cross product is a vector that is perpendicular to both vectors.\r\n   *\r\n   * @param x - The Direction to be crossed.\r\n   * @returns A new vector representing the cross product.\r\n   */\r\n  cross(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Computes the cross product of the current vector with an array of numbers.\r\n   *\r\n   * A cross product is a vector that is perpendicular to both vectors.\r\n   *\r\n   * @param x - The array of numbers representing a vector.\r\n   * @returns A new vector representing the cross product.\r\n   */\r\n  cross(x: number[]): Vec3;\r\n\r\n  cross(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return Vec3.from(\r\n      this.y * v.z - this.z * v.y,\r\n      this.z * v.x - this.x * v.z,\r\n      this.x * v.y - this.y * v.x\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Computes the distance between the current vector and a vector represented by three numbers.\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @returns The distance between the two vectors.\r\n   */\r\n  distance(x: number, y: number, z: number): number;\r\n\r\n  /**\r\n   * Computes the distance between the current vector and another Vec3.\r\n   *\r\n   * @param x - The Vec3 to measure the distance to.\r\n   * @returns The distance between the two vectors.\r\n   */\r\n  distance(x: Vec3): number;\r\n\r\n  /**\r\n   * Computes the distance between the current vector and another Vector3.\r\n   *\r\n   * @param x - The Vector3 to measure the distance to.\r\n   * @returns The distance between the two vectors.\r\n   */\r\n  distance(x: Vector3): number;\r\n\r\n  /**\r\n   * Computes the distance between the current vector and a Direction.\r\n   *\r\n   * @param x - The Direction to measure the distance to.\r\n   * @returns The distance between the two vectors.\r\n   */\r\n  distance(x: Direction): number;\r\n\r\n  /**\r\n   * Computes the distance between the current vector and a vector represented by an array of numbers.\r\n   *\r\n   * @param x - The array of numbers representing the other vector.\r\n   * @returns The distance between the two vectors.\r\n   */\r\n  distance(x: number[]): number;\r\n\r\n  distance(x: VectorLike, y?: number, z?: number): number {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return this.subtract(v).length();\r\n  }\r\n\r\n  /**\r\n   * Computes the squared distance between the current vector and a vector represented by three numbers.\r\n   * This is faster than computing the actual distance and can be useful for comparison purposes.\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @returns The squared distance between the two vectors.\r\n   */\r\n  distanceSquared(x: number, y: number, z: number): number;\r\n\r\n  /**\r\n   * Computes the squared distance between the current vector and another Vec3.\r\n   * This is faster than computing the actual distance and can be useful for comparison purposes.\r\n   *\r\n   * @param x - The Vec3 to measure the squared distance to.\r\n   * @returns The squared distance between the two vectors.\r\n   */\r\n  distanceSquared(x: Vec3): number;\r\n\r\n  /**\r\n   * Computes the squared distance between the current vector and another Vector3.\r\n   * This is faster than computing the actual distance and can be useful for comparison purposes.\r\n   *\r\n   * @param x - The Vector3 to measure the squared distance to.\r\n   * @returns The squared distance between the two vectors.\r\n   */\r\n  distanceSquared(x: Vector3): number;\r\n\r\n  /**\r\n   * Computes the squared distance between the current vector and a Direction.\r\n   * This is faster than computing the actual distance and can be useful for comparison purposes.\r\n   *\r\n   * @param x - The Direction to measure the squared distance to.\r\n   * @returns The squared distance between the two vectors.\r\n   */\r\n  distanceSquared(x: Direction): number;\r\n\r\n  /**\r\n   * Computes the squared distance between the current vector and a vector represented by an array of numbers.\r\n   * This is faster than computing the actual distance and can be useful for comparison purposes.\r\n   *\r\n   * @param x - The array of numbers representing the other vector.\r\n   * @returns The squared distance between the two vectors.\r\n   */\r\n  distanceSquared(x: number[]): number;\r\n\r\n  distanceSquared(x: VectorLike, y?: number, z?: number): number {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return this.subtract(v).lengthSquared();\r\n  }\r\n\r\n  /**\r\n   * Computes the linear interpolation between the current vector and another vector, when t is in the range [0, 1].\r\n   * Computes the extrapolation when t is outside this range.\r\n   *\r\n   * @param v - The other vector.\r\n   * @param t - The interpolation factor.\r\n   * @returns A new vector after performing the lerp operation.\r\n   */\r\n  lerp(v: Vector3, t: number): Vec3 {\r\n    if (!v || !t) return Vec3.from(this);\r\n    if (t === 1) return Vec3.from(v);\r\n    if (t === 0) return Vec3.from(this);\r\n    return Vec3.from(\r\n      this.x + (v.x - this.x) * t,\r\n      this.y + (v.y - this.y) * t,\r\n      this.z + (v.z - this.z) * t\r\n    );\r\n  }\r\n  /**\r\n   * Computes the spherical linear interpolation between the current vector and another vector, when t is in the range [0, 1].\r\n   * Computes the extrapolation when t is outside this range.\r\n   *\r\n   * @param v - The other vector.\r\n   * @param t - The interpolation factor.\r\n   * @returns A new vector after performing the slerp operation.\r\n   */\r\n  slerp(v: Vector3, t: number): Vec3 {\r\n    if (!v || !t) return Vec3.from(this);\r\n    if (t === 1) return Vec3.from(v);\r\n    if (t === 0) return Vec3.from(this);\r\n    const dot = this.dot(v);\r\n    const theta = Math.acos(dot) * t;\r\n    const relative = Vec3.from(v).subtract(this.multiply(dot)).normalize();\r\n    return this.multiply(Math.cos(theta)).add(\r\n      relative.multiply(Math.sin(theta))\r\n    );\r\n  }\r\n  /**\r\n   * Computes the dot product of the current vector with a vector specified by three numbers.\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @returns The dot product of the two vectors.\r\n   */\r\n  dot(x: number, y: number, z: number): number;\r\n\r\n  /**\r\n   * Computes the dot product of the current vector with another Vec3.\r\n   *\r\n   * @param x - The Vec3 to compute the dot product with.\r\n   * @returns The dot product of the two vectors.\r\n   */\r\n  dot(x: Vec3): number;\r\n\r\n  /**\r\n   * Computes the dot product of the current vector with another Vector3.\r\n   *\r\n   * @param x - The Vector3 to compute the dot product with.\r\n   * @returns The dot product of the two vectors.\r\n   */\r\n  dot(x: Vector3): number;\r\n\r\n  /**\r\n   * Computes the dot product of the current vector with a Direction.\r\n   *\r\n   * @param x - The Direction to compute the dot product with.\r\n   * @returns The dot product of the two vectors.\r\n   */\r\n  dot(x: Direction): number;\r\n\r\n  /**\r\n   * Computes the dot product of the current vector with a vector represented by an array of numbers.\r\n   *\r\n   * @param x - The array of numbers representing the other vector.\r\n   * @returns The dot product of the two vectors.\r\n   */\r\n  dot(x: number[]): number;\r\n\r\n  dot(x: VectorLike, y?: number, z?: number): number {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    return this.x * v.x + this.y * v.y + this.z * v.z;\r\n  }\r\n\r\n  /**\r\n   * Computes the angle (in radians) between the current vector and a vector specified by three numbers.\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @returns The angle in radians between the two vectors.\r\n   */\r\n  angleBetween(x: number, y: number, z: number): number;\r\n\r\n  /**\r\n   * Computes the angle (in radians) between the current vector and another Vec3.\r\n   *\r\n   * @param x - The Vec3 to compute the angle with.\r\n   * @returns The angle in radians between the two vectors.\r\n   */\r\n  angleBetween(x: Vec3): number;\r\n\r\n  /**\r\n   * Computes the angle (in radians) between the current vector and another Vector3.\r\n   *\r\n   * @param x - The Vector3 to compute the angle with.\r\n   * @returns The angle in radians between the two vectors.\r\n   */\r\n  angleBetween(x: Vector3): number;\r\n\r\n  /**\r\n   * Computes the angle (in radians) between the current vector and a Direction.\r\n   *\r\n   * @param x - The Direction to compute the angle with.\r\n   * @returns The angle in radians between the two vectors.\r\n   */\r\n  angleBetween(x: Direction): number;\r\n\r\n  /**\r\n   * Computes the angle (in radians) between the current vector and a vector represented by an array of numbers.\r\n   *\r\n   * @param x - The array of numbers representing the other vector.\r\n   * @returns The angle in radians between the two vectors.\r\n   */\r\n  angleBetween(x: number[]): number;\r\n\r\n  angleBetween(x: VectorLike, y?: number, z?: number): number {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    const dotProduct = this.dot(v);\r\n    const lenSq1 = this.lengthSquared();\r\n    if (lenSq1 === 0) {\r\n      return 0;\r\n    }\r\n    const lenSq2 = v.lengthSquared();\r\n    if (lenSq2 === 0) {\r\n      return 0;\r\n    }\r\n    const denom = Math.sqrt(lenSq1 * lenSq2);\r\n    // Clamp for numerical stability\r\n    const cosAngle = Math.min(1, Math.max(-1, dotProduct / denom));\r\n    return Math.acos(cosAngle);\r\n  }\r\n\r\n  /**\r\n   * Computes the projection of the current vector onto a vector specified by three numbers.\r\n   * This method finds how much of the current vector lies in the direction of the given vector.\r\n   *\r\n   * @param x - The x component of the vector to project onto.\r\n   * @param y - The y component of the vector to project onto.\r\n   * @param z - The z component of the vector to project onto.\r\n   * @returns A new vector representing the projection of the current vector.\r\n   */\r\n  projectOnto(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Computes the projection of the current vector onto another Vec3.\r\n   * This method finds how much of the current vector lies in the direction of the given vector.\r\n   *\r\n   * @param x - The Vec3 to project onto.\r\n   * @returns A new vector representing the projection of the current vector.\r\n   */\r\n  projectOnto(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Computes the projection of the current vector onto another Vector3.\r\n   * This method finds how much of the current vector lies in the direction of the given vector.\r\n   *\r\n   * @param x - The Vector3 to project onto.\r\n   * @returns A new vector representing the projection of the current vector.\r\n   */\r\n  projectOnto(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Computes the projection of the current vector onto a Direction.\r\n   * This method finds how much of the current vector lies in the direction of the given vector.\r\n   *\r\n   * @param x - The Direction to project onto.\r\n   * @returns A new vector representing the projection of the current vector.\r\n   */\r\n  projectOnto(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Computes the projection of the current vector onto a vector represented by an array of numbers.\r\n   * This method finds how much of the current vector lies in the direction of the given vector.\r\n   *\r\n   * @param x - The array of numbers representing the vector to project onto.\r\n   * @returns A new vector representing the projection of the current vector.\r\n   */\r\n  projectOnto(x: number[]): Vec3;\r\n\r\n  projectOnto(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    const v: Vec3 = Vec3._from(x, y, z);\r\n    // If the vector is zero-length, then the projection is the zero vector.\r\n    if (v.isZero()) {\r\n      return Vec3.Zero;\r\n    }\r\n    const denom = v.dot(v);\r\n    if (denom === 0) {\r\n      return Vec3.Zero;\r\n    }\r\n    const scale = this.dot(v) / denom;\r\n    return Vec3.from(v.x * scale, v.y * scale, v.z * scale);\r\n  }\r\n\r\n  /**\r\n   * Computes the reflection of the current vector against a normal vector specified by three numbers.\r\n   * Useful for simulating light reflections or bouncing objects.\r\n   *\r\n   * @param x - The x component of the normal vector.\r\n   * @param y - The y component of the normal vector.\r\n   * @param z - The z component of the normal vector.\r\n   * @returns A new vector representing the reflection of the current vector.\r\n   */\r\n  reflect(x: number, y: number, z: number): Vec3;\r\n\r\n  /**\r\n   * Computes the reflection of the current vector against another Vec3 normal vector.\r\n   * Useful for simulating light reflections or bouncing objects.\r\n   *\r\n   * @param x - The Vec3 representing the normal vector.\r\n   * @returns A new vector representing the reflection of the current vector.\r\n   */\r\n  reflect(x: Vec3): Vec3;\r\n\r\n  /**\r\n   * Computes the reflection of the current vector against another Vector3 normal vector.\r\n   * Useful for simulating light reflections or bouncing objects.\r\n   *\r\n   * @param x - The Vector3 representing the normal vector.\r\n   * @returns A new vector representing the reflection of the current vector.\r\n   */\r\n  reflect(x: Vector3): Vec3;\r\n\r\n  /**\r\n   * Computes the reflection of the current vector against a Direction normal vector.\r\n   * Useful for simulating light reflections or bouncing objects.\r\n   *\r\n   * @param x - The Direction representing the normal vector.\r\n   * @returns A new vector representing the reflection of the current vector.\r\n   */\r\n  reflect(x: Direction): Vec3;\r\n\r\n  /**\r\n   * Computes the reflection of the current vector against a normal vector represented by an array of numbers.\r\n   * Useful for simulating light reflections or bouncing objects.\r\n   *\r\n   * @param x - The array of numbers representing the normal vector.\r\n   * @returns A new vector representing the reflection of the current vector.\r\n   */\r\n  reflect(x: number[]): Vec3;\r\n\r\n  reflect(x: VectorLike, y?: number, z?: number): Vec3 {\r\n    const normal: Vec3 = Vec3._from(x, y, z);\r\n    const proj = this.projectOnto(normal);\r\n    return this.subtract(proj.multiply(2));\r\n  }\r\n\r\n  /**\r\n   * Rotates the current normalized vector by a given angle around a given axis.\r\n   *\r\n   * @param axis - The axis of rotation.\r\n   * @param angle - The angle of rotation in degrees.\r\n   * @returns The rotated vector.\r\n   */\r\n  rotate(axis: Vector3, angle: number): Vec3 {\r\n    // Convert angle from degrees to radians and compute half angle\r\n    const halfAngle = (angle * Math.PI) / 180 / 2;\r\n\r\n    // Quaternion representing the rotation\r\n    const w = Math.cos(halfAngle);\r\n    const x = axis.x * Math.sin(halfAngle);\r\n    const y = axis.y * Math.sin(halfAngle);\r\n    const z = axis.z * Math.sin(halfAngle);\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const v = this;\r\n\r\n    // Rotate vector (v) using quaternion\r\n    // Simplified direct computation reflecting quaternion rotation and its conjugate effect\r\n    const qv_x =\r\n      w * w * v.x +\r\n      2 * y * w * v.z -\r\n      2 * z * w * v.y +\r\n      x * x * v.x +\r\n      2 * y * x * v.y +\r\n      2 * z * x * v.z -\r\n      z * z * v.x -\r\n      y * y * v.x;\r\n    const qv_y =\r\n      2 * x * y * v.x +\r\n      y * y * v.y +\r\n      2 * z * y * v.z +\r\n      2 * w * z * v.x -\r\n      z * z * v.y +\r\n      w * w * v.y -\r\n      2 * x * w * v.z -\r\n      x * x * v.y;\r\n    const qv_z =\r\n      2 * x * z * v.x +\r\n      2 * y * z * v.y +\r\n      z * z * v.z -\r\n      2 * w * y * v.x -\r\n      y * y * v.z +\r\n      2 * w * x * v.y -\r\n      x * x * v.z +\r\n      w * w * v.z;\r\n\r\n    return new Vec3(qv_x, qv_y, qv_z);\r\n  }\r\n  /**\r\n   * Updates the X, Y, and Z components of the vector.\r\n   *\r\n   * @param x - The function to use to update the X value.\r\n   * @param y - The function to use to update the Y value.\r\n   * @param z - The function to use to update the Z value.\r\n   * @returns The updated vector with the new values.\r\n   */\r\n  update(\r\n    x: ((x: number) => number) | undefined,\r\n    y: ((y: number) => number) | undefined,\r\n    z: ((z: number) => number) | undefined\r\n  ): Vec3 {\r\n    if (!x) {\r\n      x = (value: number) => value;\r\n    }\r\n    if (!y) {\r\n      y = (value: number) => value;\r\n    }\r\n    if (!z) {\r\n      z = (value: number) => value;\r\n    }\r\n    return new Vec3(x(this.x), y(this.y), z(this.z));\r\n  }\r\n  /**\r\n   * Sets the X component of the vector.\r\n   *\r\n   * @param value - The new X value.\r\n   * @returns The updated vector with the new X value.\r\n   */\r\n  setX(value: number): Vec3;\r\n  setX(value: (x: number) => number): Vec3;\r\n  setX(value: number | ((x: number) => number)): Vec3 {\r\n    if (typeof value === \"number\") {\r\n      return new Vec3(value, this.y, this.z);\r\n    }\r\n    return new Vec3(value(this.x), this.y, this.z);\r\n  }\r\n  /**\r\n   * Sets the Y component of the vector.\r\n   *\r\n   * @param value - The new Y value.\r\n   * @returns The updated vector with the new Y value.\r\n   */\r\n  setY(value: number): Vec3;\r\n  setY(value: (y: number) => number): Vec3;\r\n  setY(value: number | ((y: number) => number)): Vec3 {\r\n    if (typeof value === \"number\") {\r\n      return new Vec3(this.x, value, this.z);\r\n    }\r\n    return new Vec3(this.x, value(this.y), this.z);\r\n  }\r\n  /**\r\n   * Sets the Z component of the vector.\r\n   *\r\n   * @param value - The new Z value.\r\n   * @returns The updated vector with the new Z value.\r\n   */\r\n  setZ(value: number): Vec3;\r\n  setZ(value: (z: number) => number): Vec3;\r\n  setZ(value: number | ((z: number) => number)): Vec3 {\r\n    if (typeof value === \"number\") {\r\n      return new Vec3(this.x, this.y, value);\r\n    }\r\n    return new Vec3(this.x, this.y, value(this.z));\r\n  }\r\n  /**\r\n   * Calculates the shortest distance between a point (represented by this Vector3 instance) and a line segment.\r\n   *\r\n   * This method finds the perpendicular projection of the point onto the line defined by the segment. If this\r\n   * projection lies outside the line segment, then the method calculates the distance from the point to the\r\n   * nearest segment endpoint.\r\n   *\r\n   * @param start - The starting point of the line segment.\r\n   * @param end - The ending point of the line segment.\r\n   * @returns The shortest distance between the point and the line segment.\r\n   */\r\n  distanceToLineSegment(start: Vector3, end: Vector3): number {\r\n    const lineDirection = Vec3.from(end).subtract(start);\r\n    // If the line is zero-length, then the distance is the distance to the start point.\r\n    if (lineDirection.lengthSquared() === 0) {\r\n      return this.subtract(start).length();\r\n    }\r\n    const t = Math.max(\r\n      0,\r\n      Math.min(\r\n        1,\r\n        this.subtract(start).dot(lineDirection) /\r\n          lineDirection.dot(lineDirection)\r\n      )\r\n    );\r\n    const projection = Vec3.from(start).add(lineDirection.multiply(t));\r\n    return this.subtract(projection).length();\r\n  }\r\n  /**\r\n   * Floors the X, Y, and Z components of the vector.\r\n   * @returns A new vector with the floored components.\r\n   */\r\n  floor(): Vec3 {\r\n    return this.update(Math.floor, Math.floor, Math.floor);\r\n  }\r\n  /**\r\n   * Floors the X component of the vector.\r\n   * @returns A new vector with the floored X component.\r\n   */\r\n  floorX(): Vec3 {\r\n    return this.setX(Math.floor);\r\n  }\r\n  /**\r\n   * Floors the Y component of the vector.\r\n   * @returns A new vector with the floored Y component.\r\n   */\r\n  floorY(): Vec3 {\r\n    return this.setY(Math.floor);\r\n  }\r\n  /**\r\n   * Floors the Z component of the vector.\r\n   * @returns A new vector with the floored Z component.\r\n   */\r\n  floorZ(): Vec3 {\r\n    return this.setZ(Math.floor);\r\n  }\r\n  /**\r\n   * Ceils the X, Y, and Z components of the vector.\r\n   * @returns A new vector with the ceiled components.\r\n   */\r\n  ceil(): Vec3 {\r\n    return new Vec3(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));\r\n  }\r\n  /**\r\n   * Ceils the X component of the vector.\r\n   * @returns A new vector with the ceiled X component.\r\n   */\r\n  ceilX(): Vec3 {\r\n    return this.setX(Math.ceil);\r\n  }\r\n  /**\r\n   * Ceils the Y component of the vector.\r\n   * @returns A new vector with the ceiled Y component.\r\n   */\r\n  ceilY(): Vec3 {\r\n    return this.setY(Math.ceil);\r\n  }\r\n  /**\r\n   * Ceils the Z component of the vector.\r\n   * @returns A new vector with the ceiled Z component.\r\n   */\r\n  ceilZ(): Vec3 {\r\n    return this.setZ(Math.ceil);\r\n  }\r\n  /**\r\n   * Rounds the X, Y, and Z components of the vector.\r\n   * @returns A new vector with the rounded components.\r\n   */\r\n  round(): Vec3 {\r\n    return this.update(Math.round, Math.round, Math.round);\r\n  }\r\n  /**\r\n   * Rounds the X component of the vector.\r\n   * @returns A new vector with the rounded X component.\r\n   */\r\n  roundX(): Vec3 {\r\n    return this.setX(Math.round);\r\n  }\r\n  /**\r\n   * Rounds the Y component of the vector.\r\n   * @returns A new vector with the rounded Y component.\r\n   */\r\n  roundY(): Vec3 {\r\n    return this.setY(Math.round);\r\n  }\r\n  /**\r\n   * Rounds the Z component of the vector.\r\n   * @returns A new vector with the rounded Z component.\r\n   */\r\n  roundZ(): Vec3 {\r\n    return this.setZ(Math.round);\r\n  }\r\n  /**\r\n   * Returns a new vector offset from the current vector up by 1 block.\r\n   * @returns A new vector offset from the current vector up by 1 block.\r\n   */\r\n  up(): Vec3 {\r\n    return this.add(Vec3.Up);\r\n  }\r\n  /**\r\n   * Returns a new vector offset from the current vector down by 1 block.\r\n   * @returns A new vector offset from the current vector down by 1 block.\r\n   */\r\n  down(): Vec3 {\r\n    return this.add(Vec3.Down);\r\n  }\r\n  /**\r\n   * Returns a new vector offset from the current vector north by 1 block.\r\n   * @returns A new vector offset from the current vector north by 1 block.\r\n   */\r\n  north(): Vec3 {\r\n    return this.add(Vec3.North);\r\n  }\r\n  /**\r\n   * Returns a new vector offset from the current vector south by 1 block.\r\n   * @returns A new vector offset from the current vector south by 1 block.\r\n   */\r\n  south(): Vec3 {\r\n    return this.add(Vec3.South);\r\n  }\r\n  /**\r\n   * Returns a new vector offset from the current vector east by 1 block.\r\n   * @returns A new vector offset from the current vector east by 1 block.\r\n   */\r\n  east(): Vec3 {\r\n    return this.add(Vec3.East);\r\n  }\r\n  /**\r\n   * Returns a new vector offset from the current vector west by 1 block.\r\n   * @returns A new vector offset from the current vector west by 1 block.\r\n   */\r\n  west(): Vec3 {\r\n    return this.add(Vec3.West);\r\n  }\r\n  /**\r\n   * Checks if the current vector is equal to the zero vector.\r\n   * @returns true if the vector is equal to the zero vector, else returns false.\r\n   */\r\n  isZero(): boolean {\r\n    return this.x === 0 && this.y === 0 && this.z === 0;\r\n  }\r\n  /**\r\n   * Converts the vector to an array containing the X, Y, and Z components of the vector.\r\n   * @returns An array containing the X, Y, and Z components of the vector.\r\n   */\r\n  toArray(): number[] {\r\n    return [this.x, this.y, this.z];\r\n  }\r\n  /**\r\n   * Converts the vector to a direction.\r\n   * If the vector is not a unit vector, then it will be normalized and rounded to the nearest direction.\r\n   */\r\n  toDirection(): Direction {\r\n    if (this.isZero()) {\r\n      Vec3.log.error(\r\n        new Error(\"Cannot convert zero-length vector to direction\")\r\n      );\r\n      throw new Error(\"Cannot convert zero-length vector to direction\");\r\n    }\r\n    const normalized = this.normalize();\r\n    const maxValue = Math.max(\r\n      Math.abs(normalized.x),\r\n      Math.abs(normalized.y),\r\n      Math.abs(normalized.z)\r\n    );\r\n    if (maxValue === normalized.x) return Direction.East;\r\n    if (maxValue === -normalized.x) return Direction.West;\r\n    if (maxValue === normalized.y) return Direction.Up;\r\n    if (maxValue === -normalized.y) return Direction.Down;\r\n    if (maxValue === normalized.z) return Direction.South;\r\n    if (maxValue === -normalized.z) return Direction.North;\r\n    // This should never happen\r\n    Vec3.log.error(new Error(\"Cannot convert vector to direction\"), this);\r\n    throw new Error(\"Cannot convert vector to direction\");\r\n  }\r\n  /**\r\n   * Returns a new vector with the X, Y, and Z components rounded to the nearest block location.\r\n   */\r\n  toBlockLocation(): Vec3 {\r\n    // At this point I'm not sure if it wouldn't be better to use Math.floor instead\r\n    return Vec3.from(\r\n      (this.x << 0) - (this.x < 0 && this.x !== this.x << 0 ? 1 : 0),\r\n      (this.y << 0) - (this.y < 0 && this.y !== this.y << 0 ? 1 : 0),\r\n      (this.z << 0) - (this.z < 0 && this.z !== this.z << 0 ? 1 : 0)\r\n    );\r\n  }\r\n  /**\r\n   * Checks if the current vector is almost equal to another vector defined by three numbers,\r\n   * within a given tolerance (delta).\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @param delta - The maximum allowed difference between corresponding components.\r\n   * @returns True if the vectors are almost equal; otherwise, false.\r\n   */\r\n  almostEqual(x: number, y: number, z: number, delta: number): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is almost equal to another Vec3 within a given tolerance (delta).\r\n   *\r\n   * @param x - The Vec3 to compare.\r\n   * @param delta - The maximum allowed difference between corresponding components.\r\n   * @returns True if the vectors are almost equal; otherwise, false.\r\n   */\r\n  almostEqual(x: Vec3, delta: number): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is almost equal to another Vector3 within a given tolerance (delta).\r\n   *\r\n   * @param x - The Vector3 to compare.\r\n   * @param delta - The maximum allowed difference between corresponding components.\r\n   * @returns True if the vectors are almost equal; otherwise, false.\r\n   */\r\n  almostEqual(x: Vector3, delta: number): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is almost equal to a Direction within a given tolerance (delta).\r\n   *\r\n   * @param x - The Direction to compare.\r\n   * @param delta - The maximum allowed difference between corresponding components.\r\n   * @returns True if the vectors are almost equal; otherwise, false.\r\n   */\r\n  almostEqual(x: Direction, delta: number): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is almost equal to a vector represented by an array of numbers,\r\n   * within a given tolerance (delta).\r\n   *\r\n   * @param x - The array of numbers representing the vector.\r\n   * @param delta - The maximum allowed difference between corresponding components.\r\n   * @returns True if the vectors are almost equal; otherwise, false.\r\n   */\r\n  almostEqual(x: number[], delta: number): boolean;\r\n\r\n  almostEqual(x: VectorLike, y: number, z?: number, delta?: number): boolean {\r\n    try {\r\n      let other: Vec3;\r\n      if (typeof x !== \"number\" && z === undefined) {\r\n        other = Vec3._from(x, undefined, undefined);\r\n        delta = y!;\r\n      } else {\r\n        other = Vec3._from(x, y, z);\r\n      }\r\n      return (\r\n        Math.abs(this.x - other.x) <= delta! &&\r\n        Math.abs(this.y - other.y) <= delta! &&\r\n        Math.abs(this.z - other.z) <= delta!\r\n      );\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the current vector is exactly equal to another vector defined by three numbers.\r\n   *\r\n   * @param x - The x component of the other vector.\r\n   * @param y - The y component of the other vector.\r\n   * @param z - The z component of the other vector.\r\n   * @returns True if the vectors are exactly equal; otherwise, false.\r\n   */\r\n  equals(x: number, y: number, z: number): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is exactly equal to another Vec3.\r\n   *\r\n   * @param x - The Vec3 to compare.\r\n   * @returns True if the vectors are exactly equal; otherwise, false.\r\n   */\r\n  equals(x: Vec3): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is exactly equal to another Vector3.\r\n   *\r\n   * @param x - The Vector3 to compare.\r\n   * @returns True if the vectors are exactly equal; otherwise, false.\r\n   */\r\n  equals(x: Vector3): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is exactly equal to a Direction.\r\n   *\r\n   * @param x - The Direction to compare.\r\n   * @returns True if the vectors are exactly equal; otherwise, false.\r\n   */\r\n  equals(x: Direction): boolean;\r\n\r\n  /**\r\n   * Checks if the current vector is exactly equal to a vector represented by an array of numbers.\r\n   *\r\n   * @param x - The array of numbers representing the vector.\r\n   * @returns True if the vectors are exactly equal; otherwise, false.\r\n   */\r\n  equals(x: number[]): boolean;\r\n\r\n  equals(x: VectorLike, y?: number, z?: number): boolean {\r\n    try {\r\n      const other: Vec3 = Vec3._from(x, y, z);\r\n      return this.x === other.x && this.y === other.y && this.z === other.z;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts the vector to a string representation.\r\n   *\r\n   * @param format - The format of the string representation. Defaults to \"long\".\r\n   * @param separator - The separator to use between components. Defaults to \", \".\r\n   * @returns The string representation of the vector.\r\n   * @remarks\r\n   * The \"long\" format is \"Vec3(x, y, z)\".\r\n   * The \"short\" format is \"x, y, z\".\r\n   */\r\n  toString(\r\n    format: \"long\" | \"short\" = \"long\",\r\n    separator: string = \", \"\r\n  ): string {\r\n    const result = `${this.x + separator + this.y + separator + this.z}`;\r\n    return format === \"long\" ? `Vec3(${result})` : result;\r\n  }\r\n\r\n  /**\r\n   * Parses a string representation of a vector.\r\n   *\r\n   * @param str - The string representation of the vector.\r\n   * @param format - The format of the string representation. Defaults to \"long\".\r\n   * @param separator - The separator to use between components. Defaults to \", \".\r\n   * @returns The vector parsed from the string.\r\n   * @throws {Error} If the string format is invalid.\r\n   */\r\n  static fromString(str: string, format: \"long\" | \"short\" = \"long\", separator: string = \", \"): Vec3 {\r\n    if (format === \"long\") {\r\n      const match = str.match(/^Vec3\\((.*)\\)$/);\r\n      if (!match) {\r\n        throw new Error(\"Invalid string format\");\r\n      }\r\n      const components = match[1].split(separator);\r\n      if (components.length !== 3) {\r\n        throw new Error(\"Invalid string format\");\r\n      }\r\n      return Vec3.from(Number(components[0]), Number(components[1]), Number(components[2]));\r\n    } else {\r\n      const components = str.split(separator);\r\n      if (components.length !== 3) {\r\n        throw new Error(\"Invalid string format\");\r\n      }\r\n      return Vec3.from(Number(components[0]), Number(components[1]), Number(components[2]));\r\n    }\r\n  }\r\n}\r\n", "/* eslint-disable no-unused-labels */\r\nimport { system, world } from \"@minecraft/server\";\r\nimport ChatColor from \"./ChatColor\";\r\nimport ColorJSON from \"./ColorJSON\";\r\n\r\nlet sourceMapping: any = void 0;\r\ntry {\r\n  sourceMapping = globalSourceMapping;\r\n} catch (e) {\r\n  // Ignore\r\n}\r\n\r\n/**\r\n * The `OutputType` enum defines the various types of outputs that the logger can use.\r\n */\r\nexport enum OutputType {\r\n  /**\r\n   * Uses `world.sendMessage` to send the log message to the chat.\r\n   */\r\n  Chat,\r\n  /**\r\n   * Uses `console.log` to send the log message to the console.\r\n   */\r\n  ConsoleInfo,\r\n  /**\r\n   * Uses `console.warn` to send the log message to the console as a warning.\r\n   */\r\n  ConsoleWarn,\r\n  /**\r\n   * Uses `console.error` to send the log message to the console as an error.\r\n   */\r\n  ConsoleError,\r\n}\r\n\r\n/**\r\n * The `LogLevel` class defines the various logging levels used by the logger.\r\n */\r\nexport class LogLevel {\r\n  static All: LogLevel = new LogLevel(-2, \"all\");\r\n  static Trace: LogLevel = new LogLevel(-2, \"trace\", ChatColor.DARK_AQUA);\r\n  static Debug: LogLevel = new LogLevel(-1, \"debug\", ChatColor.AQUA);\r\n  static Info: LogLevel = new LogLevel(0, \"info\", ChatColor.GREEN);\r\n  static Warn: LogLevel = new LogLevel(1, \"warn\", ChatColor.GOLD);\r\n  static Error: LogLevel = new LogLevel(2, \"error\", ChatColor.RED);\r\n  static Fatal: LogLevel = new LogLevel(3, \"fatal\", ChatColor.DARK_RED);\r\n  static Off: LogLevel = new LogLevel(100, \"off\");\r\n\r\n  /**\r\n   * The list of all available log levels.\r\n   */\r\n  static values = [\r\n    LogLevel.All,\r\n    LogLevel.Trace,\r\n    LogLevel.Debug,\r\n    LogLevel.Info,\r\n    LogLevel.Warn,\r\n    LogLevel.Error,\r\n    LogLevel.Fatal,\r\n    LogLevel.Off,\r\n  ];\r\n\r\n  /**\r\n   * The constructor for each log level.\r\n   *\r\n   * @param {number} level - The numerical level for this logger.\r\n   * @param {string} name - The string name for this logger.\r\n   * @param {ChatColor} color - The color to use for this logger. Defaults to `ChatColor.RESET`.\r\n   */\r\n  private constructor(\r\n    public readonly level: number,\r\n    public readonly name: string,\r\n    public color: ChatColor = ChatColor.RESET\r\n  ) {}\r\n\r\n  /**\r\n   * Return the logging level as a string.\r\n   *\r\n   * @returns {string} The string representation of the logging level.\r\n   */\r\n  public toString(): string {\r\n    return this.color + this.name.toUpperCase() + ChatColor.RESET;\r\n  }\r\n\r\n  /**\r\n   * Parse a string to get the corresponding `LogLevel`.\r\n   *\r\n   * @param {string} str - The string to parse.\r\n   * @returns {LogLevel} The corresponding `LogLevel`, or `undefined` if none was found.\r\n   */\r\n  static parse(str: string): LogLevel | undefined {\r\n    str = str.toLowerCase();\r\n    for (const level of LogLevel.values) {\r\n      if (level.name === str) return level;\r\n    }\r\n    // check if it is a number\r\n    const num = parseInt(str);\r\n    if (!isNaN(num)) {\r\n      for (const level of LogLevel.values) {\r\n        if (level.level === num) return level;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * The `OutputConfig` type defines the configuration for the logger's outputs.\r\n * It is a mapping of `LogLevel` to an array of `OutputType`.\r\n */\r\nexport type OutputConfig = {\r\n  [key in LogLevel[\"level\"]]?: OutputType[];\r\n};\r\n\r\n/**\r\n * Function to match the provided string to the given pattern.\r\n *\r\n * @param {string} pattern - The pattern to match.\r\n * @param {string} str - The string to match the pattern against.\r\n * @returns {boolean} return true if the pattern matches, else returns false.\r\n */\r\nfunction starMatch(pattern: string, str: string): boolean {\r\n  if (pattern === \"*\") return true;\r\n  if (pattern.includes(\"*\")) {\r\n    if (pattern.startsWith(\"*\")) {\r\n      return str.endsWith(pattern.substring(1));\r\n    }\r\n    if (pattern.endsWith(\"*\")) {\r\n      return str.startsWith(pattern.substring(0, pattern.length - 1));\r\n    }\r\n    const regex = new RegExp(pattern.replace(/\\*/g, \".*\"));\r\n    return regex.test(str);\r\n  }\r\n  return pattern === str;\r\n}\r\n\r\ntype LoggingSettings = {\r\n  filter: \"*\" | string[];\r\n  level: LogLevel;\r\n  outputTags: boolean;\r\n  formatFunction: (\r\n    level: LogLevel,\r\n    logger: Logger,\r\n    message: string,\r\n    tags?: string[] | undefined\r\n  ) => string;\r\n  messagesJoinFunction: (messages: string[]) => string;\r\n  jsonFormatter: ColorJSON;\r\n  outputConfig: OutputConfig;\r\n};\r\n\r\nconst loggingSettings: LoggingSettings = {\r\n  level: LogLevel.Info,\r\n  filter: [\"*\"],\r\n  outputTags: false,\r\n  formatFunction: (\r\n    level: LogLevel,\r\n    logger: Logger,\r\n    message: string,\r\n    tags = undefined\r\n  ) => {\r\n    const _tags =\r\n      tags !== undefined ? `7${tags.map((tag) => `[${tag}]`).join(\"\")}r` : \"\";\r\n    return `[${level}][${ChatColor.MATERIAL_EMERALD}${logger.name}${ChatColor.RESET}]${_tags} ${message}`;\r\n  },\r\n  messagesJoinFunction: (messages: string[]) => {\r\n    return messages.join(\" \");\r\n  },\r\n  jsonFormatter: ColorJSON.DEFAULT,\r\n  outputConfig: {\r\n    [LogLevel.Trace.level]: [OutputType.Chat, OutputType.ConsoleInfo],\r\n    [LogLevel.Debug.level]: [OutputType.Chat, OutputType.ConsoleInfo],\r\n    [LogLevel.Info.level]: [OutputType.Chat, OutputType.ConsoleInfo],\r\n    [LogLevel.Warn.level]: [\r\n      OutputType.Chat,\r\n      OutputType.ConsoleInfo,\r\n      OutputType.ConsoleWarn,\r\n    ],\r\n    [LogLevel.Error.level]: [\r\n      OutputType.Chat,\r\n      OutputType.ConsoleInfo,\r\n      OutputType.ConsoleError,\r\n    ],\r\n    [LogLevel.Fatal.level]: [\r\n      OutputType.Chat,\r\n      OutputType.ConsoleInfo,\r\n      OutputType.ConsoleError,\r\n    ],\r\n  },\r\n};\r\n\r\n/**\r\n * The Logger class.\r\n */\r\nexport class Logger {\r\n  private static initialized: boolean = false;\r\n  /**\r\n   *  Initialize logger class\r\n   */\r\n  static init() {\r\n    LOGGING: {\r\n      if (Logger.initialized) return;\r\n      Logger.initialized = true;\r\n      system.afterEvents.scriptEventReceive.subscribe((ev) => {\r\n        if (ev.id === \"logging:level\" || ev.id === \"log:level\") {\r\n          if (!ev.message) {\r\n            loggingSettings.level = LogLevel.Info;\r\n            world.sendMessage(\r\n              `${ChatColor.AQUA}Logging level set to ${ChatColor.BOLD}${loggingSettings.level}`\r\n            );\r\n          } else {\r\n            const level = LogLevel.parse(ev.message);\r\n            if (level) {\r\n              loggingSettings.level = level;\r\n              world.sendMessage(\r\n                `${ChatColor.AQUA}Logging level set to ${ChatColor.BOLD}${loggingSettings.level}`\r\n              );\r\n            } else {\r\n              world.sendMessage(\r\n                `${ChatColor.DARK_RED}Invalid logging level: ${ev.message}`\r\n              );\r\n            }\r\n          }\r\n        } else if (ev.id === \"logging:filter\" || ev.id === \"log:filter\") {\r\n          if (!ev.message) {\r\n            loggingSettings.filter = [\"*\"];\r\n          } else {\r\n            loggingSettings.filter = ev.message.split(\",\");\r\n          }\r\n          world.sendMessage(\r\n            `${ChatColor.AQUA}Logging filter set to ${\r\n              ChatColor.BOLD\r\n            }${loggingSettings.filter.join(\", \")}`\r\n          );\r\n        }\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * @param {LogLevel} level - The level to set.\r\n   */\r\n  static setLevel(level: LogLevel) {\r\n    loggingSettings.level = level;\r\n  }\r\n  /**\r\n   * Filter the loggers by the given tags. Tags can use the `*` wildcard.\r\n   * @param {'*' | string[]} filter - The filter to set.\r\n   */\r\n  static setFilter(filter: \"*\" | string[]) {\r\n    loggingSettings.filter = filter;\r\n  }\r\n  /**\r\n   * Set the format function for the logger.\r\n   * @param {function} func - The function to set.\r\n   */\r\n  static setFormatFunction(\r\n    func: (level: LogLevel, logger: Logger, message: string) => string\r\n  ) {\r\n    loggingSettings.formatFunction = func;\r\n  }\r\n  /**\r\n   * Set the function, that joins multiple messages into one for the logger.\r\n   * @param {function} func - The function to set.\r\n   */\r\n  static setMessagesJoinFunction(func: (messages: string[]) => string) {\r\n    loggingSettings.messagesJoinFunction = func;\r\n  }\r\n  /**\r\n   * Set the tag visibility for the logger. When true, tags will be printed in the log. Disabled by default.\r\n   * @param visible\r\n   */\r\n  static setTagsOutputVisibility(visible: boolean) {\r\n    loggingSettings.outputTags = visible;\r\n  }\r\n  /**\r\n   * Set the JSON formatter for the logger.\r\n   * @param {ColorJSON} formatter - The json formatter to set.\r\n   */\r\n  static setJsonFormatter(formatter: ColorJSON) {\r\n    loggingSettings.jsonFormatter = formatter;\r\n  }\r\n  /**\r\n   * Get the output configuration for the logger.\r\n   * @returns {OutputConfig} The output configuration.\r\n   */\r\n  static getOutputConfig(): OutputConfig {\r\n    return loggingSettings.outputConfig;\r\n  }\r\n  /**\r\n   * Returns a new Logger.\r\n   *\r\n   * @param {string} name - The name of the Logger.\r\n   * @param {string[]} tags - The tags for the Logger as strings.\r\n   *\r\n   * @returns {Logger} A new Logger.\r\n   */\r\n  static getLogger(name: string, ...tags: string[]): Logger {\r\n    LOGGING: {\r\n      if (!Logger.initialized) {\r\n        Logger.init();\r\n      }\r\n    }\r\n    return new Logger(name, tags);\r\n  }\r\n  /**\r\n   * Construct a new Logger\r\n   *\r\n   * @param {string} name - The name of the Logger.\r\n   * @param {string[]} tags - The tags for the logger as strings.\r\n   */\r\n  private constructor(public name: string, public tags: string[] = []) {}\r\n\r\n  /**\r\n   * Log messages with the level set.\r\n   *\r\n   * @param {LogLevel} level - The LogLevel to log the messages at.\r\n   * @param {array} message - An array of the messages to log.\r\n   */\r\n  private log(level: LogLevel, ...message: unknown[]) {\r\n    LOGGING: {\r\n      if (level.level < loggingSettings.level.level) return;\r\n      if (loggingSettings.filter.length === 0 || this.tags.length === 0) {\r\n        this.logRaw(level, ...message);\r\n        return;\r\n      }\r\n      for (const filter of loggingSettings.filter) {\r\n        if (filter.startsWith(\"!\")) {\r\n          if (\r\n            starMatch(filter.substring(1), this.name) ||\r\n            this.tags.some((tag) => starMatch(filter.substring(1), tag))\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n        if (\r\n          starMatch(filter, this.name) ||\r\n          this.tags.some((tag) => starMatch(filter, tag))\r\n        ) {\r\n          this.logRaw(level, ...message);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private stringifyError(x: Error): string {\r\n    let stack = x.stack ?? \"\";\r\n    if (sourceMapping) {\r\n      // This regex matches a parenthesized file location.\r\n      // It expects a file ending in \".js\", a colon, a line number, and optionally another colon with a column.\r\n      // Examples it matches:\r\n      //   (folder/fileName.js:123)\r\n      //   (folder/fileName.js:123:45)\r\n      const stackLineRegex = /\\(([^)]+\\.js):(\\d+)(?::(\\d+))?\\)/;\r\n\r\n      // Process each line of the error stack.\r\n      stack = stack\r\n        .split(\"\\n\")\r\n        .map((line) => {\r\n          const match = stackLineRegex.exec(line);\r\n          if (match) {\r\n            const filePath = match[1]; // e.g., folder/fileName.js\r\n            const lineNumber = parseInt(match[2], 10) - sourceMapping.metadata.offset;\r\n            if (filePath.includes(sourceMapping.metadata.filePath)) {\r\n              const mappingEntry = globalSourceMapping[lineNumber];\r\n              if (mappingEntry) {\r\n                // Build the replacement string using the mapped source and original line.\r\n                // We ignore the column information as you don't care about it.\r\n                const replacement = `(${mappingEntry.source}:${mappingEntry.originalLine})`;\r\n                return line.replace(stackLineRegex, replacement);\r\n              }\r\n            }\r\n          }\r\n          return line;\r\n        })\r\n        .join(\"\\n\");\r\n    }\r\n\r\n    return `${ChatColor.DARK_RED}${ChatColor.BOLD}${x.message}\\n${ChatColor.RESET}${ChatColor.GRAY}${ChatColor.ITALIC}${stack}${ChatColor.RESET}`;\r\n  }\r\n\r\n  /**\r\n   * Internal function to log messages with the level set, that bypasses the filters.\r\n   *\r\n   * @param {LogLevel} level - The LogLevel to log the messages at.\r\n   * @param {array} message - An array of the messages to log.\r\n   */\r\n  private logRaw(level: LogLevel, ...message: unknown[]) {\r\n    LOGGING: {\r\n      const msgs: string[] = message.map((x: unknown) => {\r\n        if (x === void 0) {\r\n          return ChatColor.GOLD + \"undefined\" + ChatColor.RESET;\r\n        }\r\n        if (x === null) {\r\n          return ChatColor.GOLD + \"null\" + ChatColor.RESET;\r\n        }\r\n        if (x && x instanceof Error) {\r\n          return this.stringifyError(x);\r\n        }\r\n        if (typeof x === \"object\" || Array.isArray(x)) {\r\n          return loggingSettings.jsonFormatter.stringify(x) + ChatColor.RESET;\r\n        }\r\n        return x.toString() + ChatColor.RESET;\r\n      });\r\n      const formatted = loggingSettings.formatFunction(\r\n        level,\r\n        this,\r\n        loggingSettings.messagesJoinFunction(msgs),\r\n        loggingSettings.outputTags ? this.tags : undefined\r\n      );\r\n      const outputs = loggingSettings.outputConfig[level.level] || [\r\n        OutputType.Chat,\r\n        OutputType.ConsoleInfo,\r\n      ];\r\n      if (outputs.includes(OutputType.Chat)) {\r\n        try {\r\n          world.sendMessage(formatted);\r\n        } catch (_) {\r\n          system.run(() => {\r\n            world.sendMessage(formatted);\r\n          })\r\n        }\r\n      }\r\n      if (outputs.includes(OutputType.ConsoleInfo)) {\r\n        if ((console as any).originalLog) {\r\n          (console as any).originalLog(ChatColor.stripColor(formatted));\r\n        } else {\r\n          console.log(ChatColor.stripColor(formatted));\r\n        }\r\n      }\r\n      if (outputs.includes(OutputType.ConsoleWarn)) {\r\n        console.warn(formatted);\r\n      }\r\n      if (outputs.includes(OutputType.ConsoleError)) {\r\n        console.error(formatted);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs a trace message.\r\n   *\r\n   * @param {...unknown} message - The message(s) to be logged.\r\n   */\r\n  trace(...message: unknown[]) {\r\n    LOGGING: this.log(LogLevel.Trace, ...message);\r\n  }\r\n\r\n  /**\r\n   * Logs debug message.\r\n   *\r\n   * @param {...unknown[]} message - The message(s) to be logged.\r\n   */\r\n  debug(...message: unknown[]) {\r\n    LOGGING: this.log(LogLevel.Debug, ...message);\r\n  }\r\n\r\n  /**\r\n   * Logs an informational message.\r\n   *\r\n   * @param {...unknown[]} message - The message(s) to be logged.\r\n   */\r\n  info(...message: unknown[]) {\r\n    LOGGING: this.log(LogLevel.Info, ...message);\r\n  }\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   *\r\n   * @param {...unknown[]} message - The warning message or messages to be logged.\r\n   */\r\n  warn(...message: unknown[]) {\r\n    LOGGING: this.log(LogLevel.Warn, ...message);\r\n  }\r\n\r\n  /**\r\n   * Logs an error message.\r\n   *\r\n   * @param {...unknown[]} message - The error message(s) to log.\r\n   */\r\n  error(...message: unknown[]) {\r\n    LOGGING: this.log(LogLevel.Error, ...message);\r\n  }\r\n\r\n  /**\r\n   * Logs a fatal error.\r\n   *\r\n   * @param {unknown[]} message - The error message to log.\r\n   */\r\n  fatal(...message: unknown[]) {\r\n    LOGGING: this.log(LogLevel.Fatal, ...message);\r\n  }\r\n}\r\n", "/**\r\n * ChatColor is a class for defining color codes.\r\n */\r\nexport default class ChatColor {\r\n    /**\r\n     * Black color code. (0)\r\n     */\r\n    public static readonly BLACK: ChatColor = new ChatColor('0', 0x000000);\r\n    /**\r\n     * Dark blue color code. (1)\r\n     */\r\n    public static readonly DARK_BLUE: ChatColor = new ChatColor('1', 0x0000aa);\r\n    /**\r\n     * Dark green color code. (2)\r\n     */\r\n    public static readonly DARK_GREEN: ChatColor = new ChatColor('2', 0x00aa00);\r\n    /**\r\n     * Dark aqua color code. (3)\r\n     */\r\n    public static readonly DARK_AQUA: ChatColor = new ChatColor('3', 0x00aaaa);\r\n    /**\r\n     * Dark red color code. (4)\r\n     */\r\n    public static readonly DARK_RED: ChatColor = new ChatColor('4', 0xaa0000);\r\n    /**\r\n     * Dark purple color code. (5)\r\n     */\r\n    public static readonly DARK_PURPLE: ChatColor = new ChatColor('5', 0xaa00aa);\r\n    /**\r\n     * Gold color code. (6)\r\n     */\r\n    public static readonly GOLD: ChatColor = new ChatColor('6', 0xffaa00);\r\n    /**\r\n     * Gray color code. (7)\r\n     */\r\n    public static readonly GRAY: ChatColor = new ChatColor('7', 0xaaaaaa);\r\n    /**\r\n     * Dark gray color code. (8)\r\n     */\r\n    public static readonly DARK_GRAY: ChatColor = new ChatColor('8', 0x555555);\r\n    /**\r\n     * Blue color code. (9)\r\n     */\r\n    public static readonly BLUE: ChatColor = new ChatColor('9', 0x5555ff);\r\n    /**\r\n     * Green color code. (a)\r\n     */\r\n    public static readonly GREEN: ChatColor = new ChatColor('a', 0x55ff55);\r\n    /**\r\n     * Aqua color code. (b)\r\n     */\r\n    public static readonly AQUA: ChatColor = new ChatColor('b', 0x55ffff);\r\n    /**\r\n     * Red color code. (c)\r\n     */\r\n    public static readonly RED: ChatColor = new ChatColor('c', 0xff5555);\r\n    /**\r\n     * Light purple color code. (d)\r\n     */\r\n    public static readonly LIGHT_PURPLE: ChatColor = new ChatColor('d', 0xff55ff);\r\n    /**\r\n     * Yellow color code. (e)\r\n     */\r\n    public static readonly YELLOW: ChatColor = new ChatColor('e', 0xffff55);\r\n    /**\r\n     * White color code. (f)\r\n     */\r\n    public static readonly WHITE: ChatColor = new ChatColor('f', 0xffffff);\r\n    /**\r\n     * MineCoin gold color code. (g)\r\n     */\r\n    public static readonly MINECOIN_GOLD: ChatColor = new ChatColor('g', 0xded605);\r\n    /**\r\n     * Material quartz color code. (h)\r\n     */\r\n    public static readonly MATERIAL_QUARTZ: ChatColor = new ChatColor('h', 0xe3d4d1);\r\n    /**\r\n     * Material iron color code. (i)\r\n     */\r\n    public static readonly MATERIAL_IRON: ChatColor = new ChatColor('i', 0xcecaca);\r\n    /**\r\n     * Material netherite color code. (j)\r\n     */\r\n    public static readonly MATERIAL_NETHERITE: ChatColor = new ChatColor('j', 0x443a3b);\r\n    /**\r\n     * Material redstone color code. (m)\r\n     */\r\n    public static readonly MATERIAL_REDSTONE: ChatColor = new ChatColor('m', 0x971607);\r\n    /**\r\n     * Material copper color code. (n)\r\n     */\r\n    public static readonly MATERIAL_COPPER: ChatColor = new ChatColor('n', 0xb4684d);\r\n    /**\r\n     * Material gold color code. (p)\r\n     */\r\n    public static readonly MATERIAL_GOLD: ChatColor = new ChatColor('p', 0xdeb12d);\r\n    /**\r\n     * Material emerald color code. (q)\r\n     */\r\n    public static readonly MATERIAL_EMERALD: ChatColor = new ChatColor('q', 0x11a036);\r\n    /**\r\n     * Material diamond color code. (s)\r\n     */\r\n    public static readonly MATERIAL_DIAMOND: ChatColor = new ChatColor('s', 0x2cbaa8);\r\n    /**\r\n     * Material lapis color code. (t)\r\n     */\r\n    public static readonly MATERIAL_LAPIS: ChatColor = new ChatColor('t', 0x21497b);\r\n    /**\r\n     * Material amethyst color code. (u)\r\n     */\r\n    public static readonly MATERIAL_AMETHYST: ChatColor = new ChatColor('u', 0x9a5cc6);\r\n    /**\r\n     * Obfuscated color code. (k)\r\n     */\r\n    public static readonly OBFUSCATED: ChatColor = new ChatColor('k');\r\n    /**\r\n     * Bold color code. (l)\r\n     */\r\n    public static readonly BOLD: ChatColor = new ChatColor('l');\r\n    /**\r\n     * Italic color code. (o)\r\n     */\r\n    public static readonly ITALIC: ChatColor = new ChatColor('o');\r\n    /**\r\n     * Reset color code. (r)\r\n     */\r\n    public static readonly RESET: ChatColor = new ChatColor('r');\r\n\r\n    /**\r\n     * All available color codes.\r\n     */\r\n    public static readonly VALUES: ChatColor[] = [\r\n        ChatColor.BLACK,\r\n        ChatColor.DARK_BLUE,\r\n        ChatColor.DARK_GREEN,\r\n        ChatColor.DARK_AQUA,\r\n        ChatColor.DARK_RED,\r\n        ChatColor.DARK_PURPLE,\r\n        ChatColor.GOLD,\r\n        ChatColor.GRAY,\r\n        ChatColor.DARK_GRAY,\r\n        ChatColor.BLUE,\r\n        ChatColor.GREEN,\r\n        ChatColor.AQUA,\r\n        ChatColor.RED,\r\n        ChatColor.LIGHT_PURPLE,\r\n        ChatColor.YELLOW,\r\n        ChatColor.WHITE,\r\n        ChatColor.MINECOIN_GOLD,\r\n        ChatColor.MATERIAL_QUARTZ,\r\n        ChatColor.MATERIAL_IRON,\r\n        ChatColor.MATERIAL_NETHERITE,\r\n        ChatColor.MATERIAL_REDSTONE,\r\n        ChatColor.MATERIAL_COPPER,\r\n        ChatColor.MATERIAL_GOLD,\r\n        ChatColor.MATERIAL_EMERALD,\r\n        ChatColor.MATERIAL_DIAMOND,\r\n        ChatColor.MATERIAL_LAPIS,\r\n        ChatColor.MATERIAL_AMETHYST,\r\n        ChatColor.OBFUSCATED,\r\n        ChatColor.BOLD,\r\n        ChatColor.ITALIC,\r\n        ChatColor.RESET\r\n    ];\r\n\r\n    /**\r\n     * All available color codes excluding the formatting codes.\r\n     */\r\n    public static readonly ALL_COLORS: ChatColor[] = [\r\n        ChatColor.BLACK,\r\n        ChatColor.DARK_BLUE,\r\n        ChatColor.DARK_GREEN,\r\n        ChatColor.DARK_AQUA,\r\n        ChatColor.DARK_RED,\r\n        ChatColor.DARK_PURPLE,\r\n        ChatColor.GOLD,\r\n        ChatColor.GRAY,\r\n        ChatColor.DARK_GRAY,\r\n        ChatColor.BLUE,\r\n        ChatColor.GREEN,\r\n        ChatColor.AQUA,\r\n        ChatColor.RED,\r\n        ChatColor.LIGHT_PURPLE,\r\n        ChatColor.YELLOW,\r\n        ChatColor.WHITE,\r\n        ChatColor.MINECOIN_GOLD,\r\n        ChatColor.MATERIAL_QUARTZ,\r\n        ChatColor.MATERIAL_IRON,\r\n        ChatColor.MATERIAL_NETHERITE,\r\n        ChatColor.MATERIAL_REDSTONE,\r\n        ChatColor.MATERIAL_COPPER,\r\n        ChatColor.MATERIAL_GOLD,\r\n        ChatColor.MATERIAL_EMERALD,\r\n        ChatColor.MATERIAL_DIAMOND,\r\n        ChatColor.MATERIAL_LAPIS,\r\n        ChatColor.MATERIAL_AMETHYST\r\n    ];\r\n\r\n    private r?: number;\r\n    private g?: number;\r\n    private b?: number;\r\n\r\n    /**\r\n     * Class ChatColor Constructor.\r\n     * @param code - The color code as a string.\r\n     * @param color - The color code as a hexadecimal number. Can be undefined.\r\n     */\r\n    constructor(private code: string, private color?: number) {\r\n        if (color) {\r\n            this.r = (color >> 16) & 0xff;\r\n            this.g = (color >> 8) & 0xff;\r\n            this.b = color & 0xff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * PREFIX is the section sign () used in Minecraft color codes.\r\n     */\r\n    private static readonly PREFIX = '';\r\n\r\n    /**\r\n     * Returns the string representation of the ChatColor instance,\r\n     * which includes the PREFIX followed by the color code.\r\n     * @returns A string representing the ChatColor instance\r\n     */\r\n    public toString() {\r\n        return ChatColor.PREFIX + this.code;\r\n    }\r\n\r\n    /**\r\n     * Returns the color code of the ChatColor instance.\r\n     * @returns The color code of this ChatColor instance.\r\n     */\r\n    public toRGB(): number | undefined {\r\n        return this.color;\r\n    }\r\n\r\n    /**\r\n     * Returns the hexadecimal string representation of the color code\r\n     * @returns {string | undefined} The hexadecimal representation of the color.\r\n     */\r\n    public toHex(): string | undefined {\r\n        return this.color?.toString(16);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the value of the red component.\r\n     *\r\n     * @returns {number | undefined} The value of the red component, or undefined if it is not set.\r\n     */\r\n    public getRed(): number | undefined {\r\n        return this.r;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the green value of the current color.\r\n     *\r\n     * @returns {number | undefined} The green value of the color, or undefined if it is not set.\r\n     */\r\n    public getGreen(): number | undefined {\r\n        return this.g;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the blue value of a color.\r\n     *\r\n     * @returns The blue value of the color.\r\n     * @type {number | undefined}\r\n     */\r\n    public getBlue(): number | undefined {\r\n        return this.b;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the format code associated with the chat color.\r\n     *\r\n     * @returns {string} The format code of the chat color.\r\n     */\r\n    public getCode(): string {\r\n        return this.code;\r\n    }\r\n\r\n    /**\r\n     * Removes color codes from the specified string\r\n     * @param str - The string from which color codes will be removed.\r\n     * @returns The string cleared from color codes.\r\n     */\r\n    static stripColor(str: string) {\r\n        return str.replace(/[0-9a-u]/g, '');\r\n    }\r\n\r\n    /**\r\n     * Finds the closest ChatColor code for the given RGB values\r\n     * @param r - Red part of the color.\r\n     * @param g - Green part of the color.\r\n     * @param b - Blue part of the color.\r\n     * @returns The closest ChatColor for the given RGB values.\r\n     */\r\n    static findClosestColor(r: number, g: number, b: number): ChatColor {\r\n        let minDistance = Number.MAX_VALUE;\r\n        let closestColor: ChatColor = ChatColor.WHITE;\r\n        for (const color of ChatColor.ALL_COLORS) {\r\n            if (color.r && color.g && color.b) {\r\n                const distance = Math.sqrt(Math.pow(color.r - r, 2) + Math.pow(color.g - g, 2) + Math.pow(color.b - b, 2));\r\n                if (distance < minDistance) {\r\n                    minDistance = distance;\r\n                    closestColor = color;\r\n                }\r\n            }\r\n        }\r\n        return closestColor;\r\n    }\r\n}\r\n\r\n", "import ChatColor from \"./ChatColor\";\r\n\r\ninterface Context {\r\n    indentLevel: number;\r\n    visited: WeakSet<any>;\r\n}\r\n\r\nexport default class ColorJSON {\r\n    // Tokens\r\n    public OpenObject: string = '{';\r\n    public CloseObject: string = '}';\r\n    public OpenArray: string = '[';\r\n    public CloseArray: string = ']';\r\n    public Comma: string = ',';\r\n    public KeyValueSeparator: string = ':';\r\n    public StringDelimiter: string = '\"';\r\n    public KeyDelimiter: string = '';\r\n    public Indent: string = '  ';\r\n    public NewLine: string = '\\n';\r\n    public Space: string = ' ';\r\n\r\n    // Threshold for inline representation\r\n    public InlineThreshold: number = 60;\r\n    // Maximum depth to which objects will be traversed\r\n    public MaxDepth: number = 1;\r\n    // Whether to include class names\r\n    public IncludeClassNames: boolean = true;\r\n\r\n    // Values\r\n    public FunctionValue: string = '';\r\n    public NullValue: string = 'null';\r\n    public UndefinedValue: string = 'undefined';\r\n    public TrueValue: string = 'true';\r\n    public FalseValue: string = 'false';\r\n    public CycleValue: string = '[...cycle...]';\r\n    public TruncatedObjectValue: string = '{...}';\r\n\r\n    // Colors\r\n    public OpenCloseObjectColor: ChatColor | string = ChatColor.YELLOW;\r\n    public OpenCloseArrayColor: ChatColor | string = ChatColor.AQUA;\r\n    public NumberColor: ChatColor | string = ChatColor.DARK_AQUA;\r\n    public StringColor: ChatColor | string = ChatColor.DARK_GREEN;\r\n    public BooleanColor: ChatColor | string = ChatColor.GOLD;\r\n    public NullColor: ChatColor | string = ChatColor.GOLD;\r\n    public KeyColor: ChatColor | string = ChatColor.GRAY;\r\n    public EscapeColor: ChatColor | string = ChatColor.GOLD;\r\n    public FunctionColor: ChatColor | string = ChatColor.GRAY;\r\n    public ClassColor: ChatColor | string = ChatColor.GRAY;\r\n    public ClassStyle: ChatColor | string = ChatColor.BOLD;\r\n    public CycleColor: ChatColor | string = ChatColor.DARK_RED;\r\n\r\n    /**\r\n     * The default ColorJSON instance\r\n     */\r\n    public static readonly DEFAULT: ColorJSON = new ColorJSON();\r\n\r\n    private static createPlain(): ColorJSON {\r\n        const plain = new ColorJSON();\r\n        plain.OpenCloseObjectColor = '';\r\n        plain.OpenCloseArrayColor = '';\r\n        plain.NumberColor = '';\r\n        plain.StringColor = '';\r\n        plain.BooleanColor = '';\r\n        plain.NullColor = '';\r\n        plain.KeyColor = '';\r\n        plain.EscapeColor = '';\r\n        plain.FunctionColor = '';\r\n        plain.ClassColor = '';\r\n        plain.ClassStyle = '';\r\n        plain.CycleColor = '';\r\n        return plain;\r\n    }\r\n\r\n    /**\r\n     * A ColorJSON instance that does not colorize anything.\r\n     */\r\n    public static readonly PLAIN: ColorJSON = this.createPlain();\r\n\r\n    /**\r\n     * Transforms a value into a chat-friendly, colored JSON representation.\r\n     * @param value - The value to transform.\r\n     */\r\n    public stringify(value: unknown): string {\r\n        return this.stringifyValue(value, {\r\n            indentLevel: 0,\r\n            visited: new WeakSet<any>(),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transforms a string into a JSON representation.\r\n     * @param value - The string to transform.\r\n     */\r\n    protected stringifyString(value: string): string {\r\n        // Escaping and concatenating with color, and delimiter\r\n        return this.StringColor + this.StringDelimiter + this.escapeString(value) + this.StringDelimiter + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Transforms a number into a JSON representation.\r\n     * @param value - The number to transform.\r\n     */\r\n    protected stringifyNumber(value: number): string {\r\n        // Converting to string and concatenating with colors\r\n        return this.NumberColor + value.toString() + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Transforms a boolean into a JSON representation.\r\n     * @param value - The boolean to transform.\r\n     */\r\n    protected stringifyBoolean(value: boolean): string {\r\n        // Boolean to string transformation along with colors\r\n        return this.BooleanColor + (value ? this.TrueValue : this.FalseValue) + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Transforms a function into a JSON representation.\r\n     * @param value - The function to transform.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/ban-types\r\n    protected stringifyFunction(value: Function): string {\r\n        // Functions are transformed to predefined function token\r\n        return this.FunctionColor + this.FunctionValue + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Returns a null JSON representation.\r\n     */\r\n    protected stringifyNull(): string {\r\n        // Null transformation\r\n        return this.NullColor + this.NullValue + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Returns an undefined JSON representation.\r\n     */\r\n    protected stringifyUndefined(): string {\r\n        // Undefined transformation\r\n        return this.NullColor + this.UndefinedValue + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Returns a cycle JSON representation.\r\n     */\r\n    protected stringifyCycle(): string {\r\n        return this.CycleColor + this.CycleValue + ChatColor.RESET;\r\n    }\r\n\r\n    /**\r\n     * Transforms an array into a JSON representation.\r\n     * @param value - The array to transform.\r\n     * @param indentLevel - The indentation level for pretty-printing.\r\n     */\r\n    protected stringifyArray(value: unknown[], ctx: Context): string {\r\n        const indentSpace = this.Indent.repeat(ctx.indentLevel);\r\n        // If array is empty, just returns colored `[]`\r\n        if (value.length === 0) {\r\n            return this.OpenCloseArrayColor + this.OpenArray + this.CloseArray + ChatColor.RESET;\r\n        }\r\n        let result = this.OpenCloseArrayColor + this.OpenArray + ChatColor.RESET + this.NewLine;\r\n        let compactResult = this.OpenCloseArrayColor + this.OpenArray + ChatColor.RESET;\r\n        value.forEach((item, index) => {\r\n            result += indentSpace + this.Indent + this.stringifyValue(item, this.indent(ctx));\r\n            result += (index < value.length - 1 ? this.Comma + this.NewLine : this.NewLine);\r\n\r\n            compactResult += this.stringifyValue(item, this.indent(ctx));\r\n            compactResult += (index < value.length - 1 ? this.Comma + this.Space : '');\r\n        });\r\n        result += indentSpace + this.OpenCloseArrayColor + this.CloseArray + ChatColor.RESET;\r\n        compactResult += this.OpenCloseArrayColor + this.CloseArray + ChatColor.RESET;\r\n\r\n        // If the compact representation is small enough, use it\r\n        if (compactResult.length < this.InlineThreshold) {\r\n            return compactResult;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms an object into a truncated JSON representation.\r\n     * @param value - The object to transform.\r\n     * @param className - Class Name of the object.\r\n     * @param indentLevel - The indentation level for pretty-printing.\r\n     */\r\n    protected stringifyTruncatedObject(value: object, className: string, ctx: Context): string {\r\n        return (this.IncludeClassNames ? this.ClassColor + '' + this.ClassStyle + className + ChatColor.RESET + this.Space : '') + this.TruncatedObjectValue;\r\n    }\r\n\r\n    /**\r\n     * Transforms an object into a JSON representation.\r\n     * @param value - The object to transform.\r\n     * @param className - Class Name of the object.\r\n     * @param entries - Entries of the object to transform.\r\n     * @param indentLevel - The indentation level for pretty-printing.\r\n     */\r\n    protected stringifyObject(value: object, className: string, entries: any[][], ctx: Context): string {\r\n        const indentSpace = this.Indent.repeat(ctx.indentLevel);\r\n        const prefix = (this.IncludeClassNames && className !== 'Object' ? this.ClassColor + '' + this.ClassStyle + className + ChatColor.RESET + this.Space : '');\r\n        // If object has no entries, just return `{}` possibly preceded by class name\r\n        if (entries.length === 0) {\r\n            return prefix + this.OpenCloseObjectColor + this.OpenObject + this.CloseObject + ChatColor.RESET;\r\n        }\r\n        // Create both a compact and a multi-line representation\r\n        let result = prefix + this.OpenCloseObjectColor + this.OpenObject + ChatColor.RESET + this.NewLine;\r\n        let compactResult = prefix + this.OpenCloseObjectColor + this.OpenObject + ChatColor.RESET;\r\n\r\n        // Stringify each entry\r\n        entries.forEach(([key, val], index) => {\r\n            const compactVal = this.stringifyValue(val, this.indent(ctx));\r\n            result += indentSpace + this.Indent + this.KeyColor + this.KeyDelimiter + key + this.KeyDelimiter + ChatColor.RESET + this.KeyValueSeparator + this.Space + compactVal;\r\n            result += (index < entries.length - 1) ? this.Comma + this.NewLine : this.NewLine;\r\n\r\n            compactResult += this.KeyColor + key + ChatColor.RESET + this.KeyValueSeparator + this.Space + compactVal;\r\n            compactResult += (index < entries.length - 1) ? this.Comma + this.Space : '';\r\n        });\r\n        // Close the object\r\n        result += indentSpace + this.OpenCloseObjectColor + this.CloseObject + ChatColor.RESET;\r\n        compactResult += this.OpenCloseObjectColor + this.CloseObject + ChatColor.RESET;\r\n\r\n        // If the compact representation is small enough, use it\r\n        if (compactResult.length < this.InlineThreshold) {\r\n            return compactResult;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    protected shouldTruncateObject(value: object, className: string, ctx: Context): boolean {\r\n        return !(className === 'Object' || ctx.indentLevel <= this.MaxDepth || this.MaxDepth <= 0);\r\n    }\r\n\r\n    /**\r\n     * Transforms a value of any type into a JSON representation. This function is not meant to be overridden.\r\n     * @param value - The value to transform.\r\n     * @param indentLevel - The indentation level for pretty-printing.\r\n     */\r\n    protected stringifyValue(value: unknown, ctx: Context): string {\r\n        // Stringify primitives like null, undefined, number, string, boolean\r\n        if (value === null) return this.stringifyNull();\r\n        if (value === void 0) return this.stringifyUndefined();\r\n        if (typeof value === 'number') return this.stringifyNumber(value);\r\n        if (typeof value === 'string') return this.stringifyString(value);\r\n        if (typeof value === 'boolean') return this.stringifyBoolean(value);\r\n        if (typeof value === 'function') return this.stringifyFunction(value);\r\n\r\n        // Check for cycles\r\n        if (this.isCycle(value, ctx)) {\r\n            return this.stringifyCycle();\r\n        }\r\n        this.markCycle(value, ctx);\r\n\r\n        // Stringify arrays\r\n        if (Array.isArray(value)) {\r\n            const result = this.stringifyArray(value, ctx.indentLevel ? this.indent(ctx) : ctx);\r\n            this.clearCycle(value, ctx);\r\n            return result;\r\n        }\r\n\r\n        // Stringify objects\r\n        if (typeof value === 'object') {\r\n            // Get class name\r\n            const name = value.constructor.name;\r\n            // If it's a plain object, or we haven't reached the max depth, stringify it\r\n            if (!this.shouldTruncateObject(value, name, ctx)) {\r\n                // Get all keys\r\n                const keySet: Set<string> = new Set();\r\n                // Get all keys from the prototype chain\r\n                let prototype = Object.getPrototypeOf(value);\r\n                let keys = Object.keys(prototype);\r\n                while (keys.length > 0) {\r\n                    keys.forEach(key => keySet.add(key));\r\n                    prototype = Object.getPrototypeOf(prototype);\r\n                    keys = Object.keys(prototype);\r\n                }\r\n                // Get all keys from the object itself\r\n                Object.keys(value).forEach(key => keySet.add(key));\r\n                keySet.delete('__cycleDetection__');\r\n                // Sort the keys\r\n                const allKeys = [...keySet].sort();\r\n                // Get all entries\r\n                const entries = allKeys.map((key: string) => {\r\n                    try {\r\n                        return [key, (value as any)[key] ?? void 0];\r\n                    } catch(e) {\r\n                        return [key, void 0];\r\n                    }\r\n                }).filter(([, val]) => typeof val !== 'function' && val !== void 0);\r\n                const result = this.stringifyObject(value, name, entries, ctx);\r\n                this.clearCycle(value, ctx);\r\n                return result;\r\n            } else {\r\n                const result = this.stringifyTruncatedObject(value, name, ctx);\r\n                this.clearCycle(value, ctx);\r\n                return result;\r\n            }\r\n        }\r\n        this.clearCycle(value, ctx);\r\n\r\n        // Stringify unknowns\r\n        return ChatColor.RESET + value.toString();\r\n    }\r\n\r\n    /**\r\n     * Escapes a string for JSON.\r\n     * @param str - The string to escape.\r\n     */\r\n    protected escapeString(str: string): string {\r\n        return str.replace(/\\\\/g, this.EscapeColor + '\\\\\\\\' + this.StringColor)\r\n            .replace(/\"/g, this.EscapeColor + '\\\\\"' + this.StringColor)\r\n            .replace(/\\n/g, this.EscapeColor + '\\\\n' + this.StringColor)\r\n            .replace(/\\r/g, this.EscapeColor + '\\\\r' + this.StringColor)\r\n            .replace(/\\t/g, this.EscapeColor + '\\\\t' + this.StringColor);\r\n    }\r\n\r\n    private markCycle(value: any, ctx: Context) {\r\n        ctx.visited.add(value);\r\n    }\r\n\r\n    private isCycle(value: any, ctx: Context) {\r\n        return ctx.visited.has(value);\r\n    }\r\n\r\n    private clearCycle(value: any, ctx: Context) {\r\n        ctx.visited.delete(value);\r\n    }\r\n\r\n    private indent(ctx: Context): Context {\r\n        return { ...ctx, indentLevel: ctx.indentLevel + 1 };\r\n    }\r\n}", "import { Logger } from \"./Logging\";\r\n/**\r\n * A simple class to measure the time it takes to perform an operation.\r\n */\r\nexport default class Timings {\r\n  private static readonly log = Logger.getLogger(\"Timings\", 'timings');\r\n  static lastTime = -1;\r\n  static lastOperation = \"\";\r\n\r\n  /**\r\n   * Begin measuring the time it takes to perform an operation.\r\n   * @remarks\r\n   * If another operation is already being measured, the measurement will be ended.\r\n   * \r\n   * @param operation The name of the operation.\r\n   */\r\n  static begin(operation: string) {\r\n    this.end();\r\n    this.lastTime = new Date().getTime();\r\n    this.lastOperation = operation;\r\n  }\r\n\r\n  /**\r\n   * End measuring the time it takes to perform an operation and log the result.\r\n   * @remarks\r\n   * If no operation is being measured, this method will do nothing.\r\n   */\r\n  static end() {\r\n    const time = new Date().getTime();\r\n    if (this.lastTime > 0) {\r\n      Timings.log.debug(`Operation ${this.lastOperation} took ${time - this.lastTime}ms`);\r\n    }\r\n    this.lastTime = -1;\r\n  }\r\n}", "import { system } from \"@minecraft/server\";\r\n\r\nlet runId = -1;\r\n\r\n/**\r\n * Schedules a dummy function each tick to fix the issues with the profiler.\r\n * Somehow the profiler adds the idle time waiting for the next tick to the last\r\n * function that was called. This is a workaround to fix that.\r\n * \r\n * Ensure, that you call this function so that the `system.runInterval` inside will \r\n * run the dummy function always as the last function in a tick.\r\n * \r\n * The call that was chosen to be the dummy function is `system.currentTick`.\r\n */\r\nexport function addIdleDummy() {\r\n  if (runId !== -1) return;\r\n  runId = system.runInterval(idle, 1);\r\n}\r\n\r\nfunction idle() {\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  const dummy = system.currentTick;\r\n}\r\n\r\n/**\r\n * Clears the dummy function that was scheduled by `addIdleDummy`.\r\n */\r\nexport function clearIdleDummy() {\r\n  if (runId === -1) return;\r\n  system.clearRun(runId);\r\n}", "import { NumberRange } from \"@minecraft/common\";\r\nimport { BlockPermutation, Dimension, world } from \"@minecraft/server\";\r\n\r\nconst dimensions: { [key: string]: Dimension } = {};\r\n\r\nconst dimensionHeightRanges: { [key: string]: NumberRange } = {};\r\n\r\nconst permutations: { [key: string]: BlockPermutation } = {};\r\n\r\n/**\r\n * Returns a dimension from the cache or gets it from the API and caches it.\r\n * @param name The name of the dimension.\r\n * @returns The dimension.\r\n */\r\nexport function getDimension(name: string) {\r\n  if (dimensions[name]) return dimensions[name];\r\n  return dimensions[name] = world.getDimension(name);\r\n}\r\n\r\n/**\r\n * Returns a dimension height range from the cache or gets it from the API and caches it.\r\n * @param name The name of the dimension.\r\n * @returns The dimension height range.\r\n */\r\nexport function getDimensionHeightRange(name: string) {\r\n  if (dimensionHeightRanges[name]) return dimensionHeightRanges[name];\r\n  return dimensionHeightRanges[name] = getDimension(name).heightRange;\r\n}\r\n\r\n/**\r\n * Returns a block permutation from the cache or gets it from the API and caches it.\r\n * @param blockName The name of the block.\r\n * @param states The block states.\r\n * @returns The block permutation.\r\n */\r\nexport function getBlockPermutation(blockName: string, states?: Record<string, boolean | number | string>): BlockPermutation {\r\n  const key = `${blockName}:${JSON.stringify(states)}`;\r\n  if (permutations[key]) return permutations[key];\r\n  return permutations[key] = BlockPermutation.resolve(blockName, states);\r\n}", "import { world } from \"@minecraft/server\";\r\nimport { install as playerInstall } from \"./PlayerPolyfill\";\r\n\r\nexport default class Polyfill {\r\n  private static _installed: Map<string, boolean> = new Map<string, boolean>();\r\n  /**\r\n   * Installs the polyfill for the console.\r\n   * \r\n   * This polyfill makes `console.log` send a message to the world chat.\r\n   */\r\n  public static installConsole(): void {\r\n    if (this._installed.get('console')) return;\r\n    this._installed.set('console', true);\r\n    (console as any).originalLog = console.log;\r\n    console.log = (...args: any[]) => {\r\n      (console as any).originalLog(...args);\r\n      const message = args.join(' ');\r\n      world.sendMessage(message);\r\n    };\r\n  }\r\n  /**\r\n   * Installs the polyfill for the player.\r\n   * \r\n   * This polyfill adds the following methods to the player:\r\n   * - applyImpulse\r\n   * - clearVelocity\r\n   */\r\n  public static installPlayer(): void {\r\n    if (this._installed.get('player')) return;\r\n    this._installed.set('player', true);\r\n    playerInstall();\r\n  }\r\n}", "import { Entity, Player, Vector3 } from \"@minecraft/server\";\r\nimport { isVersion2 } from \"../utils/VersionUtils\";\r\n\r\n/**\r\n * Applies an impulse to a player.\r\n * @param player The player to apply the impulse to.\r\n * @param vector The vector of the impulse.\r\n *\r\n * @author https://github.com/SIsilicon (https://github.com/JaylyDev/ScriptAPI/tree/main/scripts/player-impulse)\r\n */\r\n// function applyImpulse(player: Player, vector: Vector3) {\r\n//   const { x, y, z } = vector;\r\n//   const horizontal = Math.sqrt(x * x + z * z) * 2.0;\r\n//   const vertical = y < 0.0 ? 0.5 * y : y;\r\n//   player.applyKnockback(x, z, horizontal, vertical);\r\n// }\r\n\r\n/**\r\n * New implementation of applyImpulse. This one tries to replicate the behavior of\r\n * the normal impulse as much as possible.\r\n * @param entity The entity to apply the impulse to.\r\n * @param vector The vector of the impulse.\r\n */\r\nfunction applyImpulseNew(entity: Entity, vector: Vector3) {\r\n  const { x, y, z } = vector;\r\n  const previousVelocity = entity.getVelocity();\r\n\r\n  // Calculate the norm (magnitude) of the horizontal components (x and z)\r\n  const horizontalNorm = Math.sqrt(x * x + z * z);\r\n\r\n  // Calculate directionX and directionZ as normalized values\r\n  let directionX = 0;\r\n  let directionZ = 0;\r\n  if (horizontalNorm !== 0) {\r\n    directionX = x / horizontalNorm;\r\n    directionZ = z / horizontalNorm;\r\n  }\r\n\r\n  // The horizontalStrength is the horizontal norm of the input vector\r\n  // multiplied by 2.5 based on experimentation\r\n  const horizontalStrength = horizontalNorm * 2.5;\r\n\r\n  // The vertical component is directly taken as verticalStrength\r\n  // The previous velocity is also taken into account, because normal impulse retains\r\n  // the previous velocity and knockback does not\r\n  const verticalStrength = y + previousVelocity.y * 0.9;\r\n\r\n  // Apply the knockback\r\n  if (isVersion2(entity)) {\r\n    (entity as any).applyKnockback(\r\n      {\r\n        x: horizontalStrength * directionX,\r\n        z: horizontalStrength * directionZ,\r\n      },\r\n      verticalStrength\r\n    );\r\n  } else {\r\n    (entity as any).applyKnockback(directionX, directionZ, horizontalStrength, verticalStrength);\r\n  }\r\n}\r\n\r\n/**\r\n * Clears the velocity of an entity. This applies a knockback with the opposite\r\n * direction and the same strength as the current velocity in horizontal direction.\r\n * @param entity The entity to clear the velocity of.\r\n */\r\nfunction clearVelocity(entity: Entity) {\r\n  const { x, z } = entity.getVelocity();\r\n\r\n  // Calculate the norm (magnitude) of the horizontal components (x and z)\r\n  const horizontalNorm = Math.sqrt(x * x + z * z);\r\n\r\n  // Calculate directionX and directionZ as normalized values\r\n  let directionX = 0;\r\n  let directionZ = 0;\r\n  if (horizontalNorm !== 0) {\r\n    directionX = -x / horizontalNorm;\r\n    directionZ = -z / horizontalNorm;\r\n  }\r\n\r\n  // Apply the knockback\r\n  if (isVersion2(entity)) {\r\n    (entity as any).applyKnockback(\r\n      {\r\n        x: horizontalNorm * directionX,\r\n        z: horizontalNorm * directionZ,\r\n      },\r\n      0\r\n    );\r\n  } else {\r\n    (entity as any).applyKnockback(directionX, directionZ, horizontalNorm, 0);\r\n  }\r\n}\r\n\r\nexport function install() {\r\n  Player.prototype.applyImpulse = function (vector: Vector3) {\r\n    applyImpulseNew(this, vector);\r\n  };\r\n\r\n  Player.prototype.clearVelocity = function () {\r\n    clearVelocity(this);\r\n  };\r\n}\r\n", "import { Entity } from \"@minecraft/server\";\r\n\r\n/**\r\n * Returns true if the script API version is 2.0.0 or higher, otherwise false.\r\n * @param entity The entity to check.\r\n * @returns True if the script API version is 2.0.0 or higher, otherwise false.\r\n * @remarks\r\n * This function is a workaround, that checks whether isValid is a boolean or a function.\r\n */\r\nexport function isVersion2(entity: Entity): boolean {\r\n    return typeof Object.getPrototypeOf(entity).isValid !== 'function';\r\n}\r\n\r\n/**\r\n * Returns true if the entity is valid, otherwise false.\r\n * @param entity The entity to check.\r\n * @returns True if the entity is valid, otherwise false.\r\n * @remarks\r\n * This function is a workaround, that checks isValid both as a boolean and a function.\r\n */\r\nexport function isValid(entity: Entity): boolean {\r\n    const f = Object.getPrototypeOf(entity).isValid;\r\n    if (typeof f === 'function') {\r\n        return f.call(entity) as boolean;\r\n    }\r\n    return (entity.isValid as any) as boolean;\r\n}", "/* eslint-disable no-constant-condition */\r\nimport { system } from \"@minecraft/server\";\r\nimport { Logger } from \"../Logging\";\r\n\r\nconst log = Logger.getLogger(\"jobUtils\", \"bedrock-boost\", \"jobUtils\");\r\n\r\n/**\r\n * Runs a job and returns a promise that resolves when the job is done.\r\n * @param generator The generator function to run.\r\n * @returns A promise that resolves when the job is done.\r\n * @example\r\n * ```ts\r\n * const dimension = world.getDimension(MinecraftDimensionTypes.overworld);\r\n * function* generator(startLocation: Vec3): Generator<void, Block | undefined, void> {\r\n *   for (let x = 0; x < 10; x++) {\r\n *     for (let z = 0; z < 10; z++) {\r\n *       for (let y = 0; y < 10; y++) {\r\n *         const location = startLocation.add(x, y, z);\r\n *         const block = dimension.getBlock(location);\r\n *         if (block && block.isSolid) {\r\n *           return block;\r\n *         }\r\n *         yield;\r\n *       }\r\n *     }\r\n *   }\r\n * }\r\n * jobPromise(generator(Vec3.from(0, 0, 0)))\r\n *   .then(console.log);\r\n * ```\r\n */\r\nexport function jobPromise<Result>(generator: Generator<void, Result, void>): Promise<Result> {\r\n  return new Promise((resolve, reject) => {\r\n    if (system.runJob) {\r\n      system.runJob(function* () {\r\n        while (true) {\r\n          try {\r\n            const { done: d, value } = generator.next();\r\n            if (d) {\r\n              resolve(value as Result);\r\n              return;\r\n            } else {\r\n              yield;\r\n            }\r\n          } catch (err) {\r\n            reject(err);\r\n            return;\r\n          }\r\n        }\r\n      }());\r\n    } else {\r\n      log.debug(\"system.runJob is not available. Running job in an inefficient way.\");\r\n      const run = () => {\r\n        const startTime = Date.now();\r\n        while (true) {\r\n          try {\r\n            const { done: d, value } = generator.next();\r\n            if (d) {\r\n              resolve(value as Result);\r\n              return;\r\n            } else {\r\n              if (Date.now() - startTime > 4) {\r\n                system.runTimeout(run, 1);\r\n                return;\r\n              }\r\n            }\r\n          } catch (err) {\r\n            reject(err);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      run();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Runs a job and returns a promise that resolves when the job is done. The promise also reports progress once per tick.\r\n * @param generator The generator function to run.\r\n * @param onProgress The function to call when progress is reported.\r\n * @returns A promise that resolves when the job is done.\r\n * @example\r\n * ```ts\r\n * const dimension = world.getDimension(MinecraftDimensionTypes.overworld);\r\n * function* generator(startLocation: Vec3): Generator<number, Block | undefined, void> {\r\n *   const total = 10 * 10 * 10;\r\n *   for (let x = 0; x < 10; x++) {\r\n *     for (let z = 0; z < 10; z++) {\r\n *       for (let y = 0; y < 10; y++) {\r\n *         const location = startLocation.add(x, y, z);\r\n *         const block = dimension.getBlock(location);\r\n *         if (block && block.isSolid) {\r\n *           return block;\r\n *         }\r\n *         yield (x * 10 * 10 + z * 10 + y) / total;\r\n *       }\r\n *     }\r\n *   }\r\n * }\r\n * jobProgressPromise(generator(Vec3.from(0, 0, 0)), console.log)\r\n *   .then(console.log);\r\n * ```\r\n */\r\nexport function jobProgressPromise<Progress, Result>(generator: Generator<Progress, Result, void>, onProgress: (progress: Progress) => void): Promise<Result> {\r\n  return new Promise((resolve, reject) => {\r\n    if (system.runJob) {\r\n      system.runJob(function* () {\r\n        let lastTick = 0;\r\n        while (true) {\r\n          try {\r\n            const { done: d, value } = generator.next();\r\n            if (d) {\r\n              resolve(value as Result);\r\n              return;\r\n            } else {\r\n              // Limit progress updates to once per tick.\r\n              if (system.currentTick !== lastTick) {\r\n                onProgress(value as Progress);\r\n                lastTick = system.currentTick;\r\n              }\r\n              yield;\r\n            }\r\n          } catch (err) {\r\n            reject(err);\r\n            return;\r\n          }\r\n        }\r\n      }());\r\n    } else {\r\n      log.debug(\"system.runJob is not available. Running job in an inefficient way.\");\r\n      const run = () => {\r\n        const startTime = Date.now();\r\n        let sentProgress = false;\r\n        while (true) {\r\n          try {\r\n            const { done: d, value } = generator.next();\r\n            if (d) {\r\n              resolve(value as Result);\r\n              return;\r\n            } else {\r\n              // Limit progress updates to once per tick.\r\n              if (!sentProgress) {\r\n                onProgress(value as Progress);\r\n                sentProgress = true;\r\n              }\r\n              if (Date.now() - startTime > 4) {\r\n                system.runTimeout(run, 1);\r\n                return;\r\n              }\r\n            }\r\n          } catch (err) {\r\n            reject(err);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      run();\r\n    }\r\n  });\r\n}", "import { Dimension, Vector3 } from \"@minecraft/server\";\r\nimport { getDimensionHeightRange } from \"../Cache\";\r\n\r\nexport function isValidLocation(dimension:Dimension|string, location:Vector3):boolean {\r\n    if (typeof dimension !== \"string\") {\r\n        dimension = dimension.id;\r\n    }\r\n    const range = getDimensionHeightRange(dimension);\r\n    return location.y >= range.min && location.y <= range.max;\r\n}", "import { system } from \"@minecraft/server\";\r\nimport { Logger } from \"../Logging\";\r\n\r\n/**\r\n * Represents a scheduler that executes a processor function at regular intervals for each item in the list.\r\n * @template T The type of items in the scheduler.\r\n */\r\nexport default class PulseScheduler<T> {\r\n\r\n  private static readonly log: Logger = Logger.getLogger(\"PulseScheduler\", \"bedrock-boost\", \"pulse-scheduler\");\r\n  protected items: T[] = [];\r\n  private period: number;\r\n  private currentTick: number = 0;\r\n  private runId?: number;\r\n  private nextIndex: number = 0;\r\n  private executionSchedule: number[] = [];\r\n  processor: (t: T) => void;\r\n\r\n  /**\r\n   * Creates a new PulseScheduler instance.\r\n   * @param period The period of the scheduler.\r\n   */\r\n  constructor(processor: (t: T) => void, period: number) {\r\n    if (period <= 0) {\r\n      throw new Error(\"Period must be a positive integer.\");\r\n    }\r\n    if (!processor || typeof processor !== \"function\") {\r\n      throw new Error(\"Processor function must be defined.\");\r\n    }\r\n    this.period = period;\r\n    this.processor = processor;\r\n  }\r\n\r\n  /**\r\n   * Adds an item to the schedule.\r\n   * @param item The item to be added.\r\n   * @deprecated Use `push` instead.\r\n   */\r\n  add(item: T) {\r\n    this.push(item);\r\n  }\r\n\r\n  /**\r\n    * Adds multiple items to the schedule.\r\n    * \r\n    * @param items - The items to be added.\r\n    * @deprecated Use `push` instead.\r\n    */\r\n  addAll(items: T[]) {\r\n    this.push(...items);\r\n  }\r\n\r\n  /**\r\n   * Removes an item from the schedule at the specified index.\r\n   * @param index - The index of the item to remove.\r\n   */\r\n  remove(index: number) {\r\n    if (index >= 0 && index < this.items.length) {\r\n      this.items.splice(index, 1);\r\n      // Adjust nextTaskIndex if necessary to maintain execution order\r\n      if (index < this.nextIndex) {\r\n        this.nextIndex--;\r\n      }\r\n      this.recalculateExecutionSchedule();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes items from the schedule that satisfy the given predicate.\r\n   * \r\n   * @param predicate - The predicate function used to determine if an item should be removed.\r\n   */\r\n  removeIf(predicate: (t: T) => boolean) {\r\n    for (let i = this.items.length - 1; i >= 0; i--) {\r\n      if (predicate(this.items[i])) {\r\n        this.remove(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a list of the items in the schedule.\r\n   */\r\n  getItems(): ReadonlyArray<T> {\r\n    return this.items;\r\n  }\r\n\r\n  /**\r\n   * Starts the schedule.\r\n   */\r\n  start() {\r\n    this.stop();\r\n    this.currentTick = 0;\r\n    this.nextIndex = 0;\r\n    this.runId = system.runInterval(() => this.tick(), 1);\r\n  }\r\n\r\n  /**\r\n   * Stops the schedule.\r\n   */\r\n  stop() {\r\n    if (this.runId !== undefined) {\r\n      system.clearRun(this.runId);\r\n      this.runId = undefined;\r\n    }\r\n  }\r\n\r\n  private recalculateExecutionSchedule() {\r\n    // Calculate the number of executions per tick\r\n    const totalExecutions = this.items.length;\r\n    this.executionSchedule = new Array(this.period).fill(0);\r\n    if (totalExecutions === 0) {\r\n      return;\r\n    }\r\n    const interval = this.period / totalExecutions;\r\n    for (let i = 0; i < totalExecutions; i++) {\r\n      this.executionSchedule[Math.round(interval * i) % this.period]++;\r\n    }\r\n  }\r\n\r\n  private tick() {\r\n    if (this.items.length === 0) {\r\n      PulseScheduler.log.trace(\"No items to process.\");\r\n      return;\r\n    }\r\n    // Number of items to process this tick\r\n    const scheduledExecutions = this.executionSchedule[this.currentTick];\r\n    if (scheduledExecutions === 0) {\r\n      PulseScheduler.log.trace(\"No items to process this tick.\");\r\n      // Increment the tick counter\r\n      this.currentTick = (this.currentTick + 1) % this.period;\r\n      // Reset the index if we're at the end of the period\r\n      if (this.currentTick === 0) {\r\n        this.nextIndex = 0;\r\n      }\r\n      return;\r\n    }\r\n    // Execution counter for this tick\r\n    let executed = 0;\r\n\r\n    // Process items according to the schedule\r\n    // If we reach the end of the list without having correct number of executions, stop. \r\n    // It's most likely caused by an item being removed.\r\n    for (; this.nextIndex < this.items.length && executed < scheduledExecutions; this.nextIndex++) {\r\n      try {\r\n        this.processor(this.items[this.nextIndex]);\r\n      } catch (e) {\r\n        PulseScheduler.log.error(\"Error processing item\", e);\r\n      }\r\n      executed++;\r\n    }\r\n\r\n    // Increment the tick counter\r\n    this.currentTick = (this.currentTick + 1) % this.period;\r\n\r\n    // Reset the index if we're at the end of the period\r\n    if (this.currentTick === 0) {\r\n      this.nextIndex = 0;\r\n    }\r\n  }\r\n\r\n  push(...items: T[]): number {\r\n    this.items.push(...items);\r\n    this.recalculateExecutionSchedule();\r\n    return this.items.length;\r\n  }\r\n\r\n  pop(): T | undefined {\r\n    const item = this.items.pop();\r\n    this.recalculateExecutionSchedule();\r\n    return item;\r\n  }\r\n\r\n  shift(): T | undefined {\r\n    const item = this.items.shift();\r\n    this.recalculateExecutionSchedule();\r\n    return item;\r\n  }\r\n\r\n  unshift(...items: T[]): number {\r\n    this.items.unshift(...items);\r\n    this.recalculateExecutionSchedule();\r\n    return this.items.length;\r\n  }\r\n\r\n  splice(start: number, deleteCount?: number): T[];\r\n  splice(start: number, deleteCount: number, ...items: T[]): T[];\r\n  splice(start: number, deleteCount: number = 0, ...items: T[]): T[] {\r\n    const removed = this.items.splice(start, deleteCount, ...items);\r\n    this.recalculateExecutionSchedule();\r\n    return removed;\r\n  }\r\n\r\n}", "import PulseScheduler from \"./PulseScheduler\";\r\n\r\n/**\r\n * Represents a scheduler for executing tasks.\r\n */\r\nexport default class TaskPulseScheduler extends PulseScheduler<() => void> {\r\n  /**\r\n   * Creates a new TaskSchedule instance.\r\n   * @param period The period of the schedule.\r\n   */\r\n  constructor(period: number) {\r\n    super(task => task(), period);\r\n  }\r\n}", "import PulseScheduler from \"./PulseScheduler\";\r\n\r\n/**\r\n * Represents a PulseScheduler that only adds unique items to the schedule.\r\n */\r\nexport default class UniquePulseScheduler<T> extends PulseScheduler<T> {\r\n\r\n  /**\r\n   * Creates a new UniquePulseScheduler instance.\r\n   * @param period The period of the scheduler.\r\n   */\r\n  constructor(processor: (t: T) => void, period: number, private equalityFunction: (a: T, b: T) => boolean = (a, b) => a === b) {\r\n    super(processor, period);\r\n  }\r\n\r\n\r\n  push(...items: T[]): number {\r\n    const filtered = items.filter(item => !this.items.some(existingItem => this.equalityFunction(existingItem, item)));\r\n    return super.push(...filtered);\r\n  }\r\n\r\n  unshift(...items: T[]): number {\r\n    const filtered = items.filter(item => !this.items.some(existingItem => this.equalityFunction(existingItem, item)));\r\n    return super.unshift(...filtered);\r\n  }\r\n\r\n  splice(start: number, deleteCount?: number | undefined): T[];\r\n  splice(start: number, deleteCount: number, ...items: T[]): T[];\r\n  splice(start: number, deleteCount?: number, ...items: T[]): T[] {\r\n    if (deleteCount === void 0) {\r\n      return super.splice(start);\r\n    }\r\n    const filtered = items.filter(item => !this.items.some(existingItem => this.equalityFunction(existingItem, item)));\r\n    return super.splice(start, deleteCount, ...filtered);\r\n  }\r\n\r\n}", "import {\r\n  Entity,\r\n  EntityQueryOptions,\r\n  system,\r\n  world,\r\n} from \"@minecraft/server\";\r\nimport PulseScheduler from \"./PulseScheduler\";\r\nimport { Logger } from \"../Logging\";\r\nimport { isValid } from \"../utils/VersionUtils\";\r\n\r\n/**\r\n * Represents a PulseScheduler that processes entities matching a query.\r\n */\r\nexport default class EntityPulseScheduler extends PulseScheduler<Entity> {\r\n  private static readonly logger = Logger.getLogger(\r\n    \"EntityPulseScheduler\",\r\n    \"bedrock-boost\",\r\n    \"entity-pulse-scheduler\"\r\n  );\r\n  /**\r\n   * Creates a new EntityPulseScheduler instance.\r\n   * @param period The period of the scheduler.\r\n   * @param queryOptions The query options to use when querying for entities.\r\n   */\r\n  constructor(\r\n    processor: (t: Entity) => void,\r\n    period: number,\r\n    private queryOptions: EntityQueryOptions\r\n  ) {\r\n    super((t: Entity) => {\r\n      if (isValid(t)) {\r\n        processor(t);\r\n      } else {\r\n        this.removeIf((entity) => !isValid(entity));\r\n      }\r\n    }, period);\r\n    this.push(\r\n      ...world\r\n        .getDimension('minecraft:overworld')\r\n        .getEntities(this.queryOptions)\r\n    );\r\n    this.push(\r\n      ...world\r\n        .getDimension('minecraft:nether')\r\n        .getEntities(this.queryOptions)\r\n    );\r\n    this.push(\r\n      ...world\r\n        .getDimension('minecraft:the_end')\r\n        .getEntities(this.queryOptions)\r\n    );\r\n  }\r\n\r\n  private compareEntities(a: Entity, b: Entity): boolean {\r\n    return a.id === b.id;\r\n  }\r\n\r\n  start(): void {\r\n    world.afterEvents.entityLoad.subscribe((event) => {\r\n      this.addIfMatchesWithRetry(event.entity);\r\n    });\r\n    world.afterEvents.entitySpawn.subscribe((event) => {\r\n      this.addIfMatchesWithRetry(event.entity);\r\n    });\r\n    world.afterEvents.entityRemove.subscribe((event) => {\r\n      this.removeIf(\r\n        (entity) => !isValid(entity) || entity.id === event.removedEntityId\r\n      );\r\n    });\r\n    super.start();\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to the scheduler if it matches the query options. In case the entity is not valid, it will retry a tick later.\r\n   * @param entity The entity to add.\r\n   */\r\n  private addIfMatchesWithRetry(entity: Entity): void {\r\n    try {\r\n      if (!entity) {\r\n        return;\r\n      }\r\n      // Special case for when the entity is loaded from a structure and removed the same tick\r\n      if (!isValid(entity)) {\r\n        system.runInterval(() => {\r\n          if (isValid(entity) && entity.matches(this.queryOptions)) {\r\n            this.push(entity);\r\n          }\r\n        }, 1);\r\n      } else if (entity.matches(this.queryOptions)) {\r\n        this.push(entity);\r\n      }\r\n    } catch (e) {\r\n      //TODO: Maybe it should be scheduled for reprocessing?\r\n      EntityPulseScheduler.logger.debug(\r\n        \"Failed to push entity to scheduler.\",\r\n        e\r\n      );\r\n    }\r\n  }\r\n\r\n  push(...items: Entity[]): number {\r\n    const filtered = items.filter(\r\n      (item) =>\r\n        isValid(item) &&\r\n        !this.items.some((existingItem) =>\r\n          this.compareEntities(existingItem, item)\r\n        )\r\n    );\r\n    return super.push(...filtered);\r\n  }\r\n\r\n  unshift(...items: Entity[]): number {\r\n    const filtered = items.filter(\r\n      (item) =>\r\n        isValid(item) &&\r\n        !this.items.some((existingItem) =>\r\n          this.compareEntities(existingItem, item)\r\n        )\r\n    );\r\n    return super.unshift(...filtered);\r\n  }\r\n\r\n  splice(start: number, deleteCount?: number | undefined): Entity[];\r\n  splice(start: number, deleteCount: number, ...items: Entity[]): Entity[];\r\n  splice(start: number, deleteCount?: number, ...items: Entity[]): Entity[] {\r\n    if (deleteCount === void 0) {\r\n      return super.splice(start);\r\n    }\r\n    const filtered = items.filter(\r\n      (item) =>\r\n        !this.items.some((existingItem) =>\r\n          this.compareEntities(existingItem, item)\r\n        )\r\n    );\r\n    return super.splice(start, deleteCount, ...filtered);\r\n  }\r\n}\r\n", "import { Player, system, world } from \"@minecraft/server\";\r\nimport PulseScheduler from \"./PulseScheduler\";\r\nimport { Logger } from \"../Logging\";\r\nimport { isValid } from \"../utils/VersionUtils\";\r\n\r\n/**\r\n * Represents a PulseScheduler that processes players.\r\n */\r\nexport default class PlayerPulseScheduler extends PulseScheduler<Player> {\r\n\r\n  private static readonly logger = Logger.getLogger(\"PlayerPulseScheduler\", \"bedrock-boost\", \"player-pulse-scheduler\");\r\n\r\n  /**\r\n   * Creates a new PlayerPulseScheduler instance.\r\n   * @param period The period of the scheduler.\r\n   */\r\n  constructor(processor: (t: Player) => void, period: number) {\r\n    super((t: Player) => {\r\n      if (isValid(t)) {\r\n        processor(t);\r\n      } else {\r\n        this.removeIf((entity) => !isValid(entity));\r\n      }\r\n    }, period);\r\n    this.push(...world.getAllPlayers());\r\n  }\r\n\r\n  private compareEntities(a: Player, b: Player): boolean {\r\n    return a.id === b.id;\r\n  }\r\n\r\n  start(): void {\r\n    world.afterEvents.playerJoin.subscribe((event) => {\r\n      let attempts = 0;\r\n      const pushPlayer = () => {\r\n        attempts++;\r\n        if (attempts > 10) {\r\n          PlayerPulseScheduler.logger.debug(\"Failed to push player to scheduler after 10 attempts.\");\r\n          return;\r\n        }\r\n        try {\r\n          const player = world.getEntity(event.playerId);\r\n          if (player === void 0) {\r\n            system.runTimeout(pushPlayer, 1);\r\n          }\r\n          if (player instanceof Player) {\r\n            this.push(player);\r\n          }\r\n        } catch (e) {\r\n          PlayerPulseScheduler.logger.debug(\"Failed to push player to scheduler.\", e);\r\n          system.runTimeout(pushPlayer, 1);\r\n        }\r\n      }\r\n      pushPlayer();\r\n    });\r\n    world.afterEvents.playerLeave.subscribe((event) => {\r\n      this.removeIf((entity) => !isValid(entity) || entity.id === event.playerId);\r\n    });\r\n    super.start();\r\n  }\r\n\r\n  push(...items: Player[]): number {\r\n    const filtered = items.filter(item => isValid(item) && !this.items.some(existingItem => this.compareEntities(existingItem, item)));\r\n    return super.push(...filtered);\r\n  }\r\n\r\n  unshift(...items: Player[]): number {\r\n    const filtered = items.filter(item => isValid(item) && !this.items.some(existingItem => this.compareEntities(existingItem, item)));\r\n    return super.unshift(...filtered);\r\n  }\r\n\r\n  splice(start: number, deleteCount?: number | undefined): Player[];\r\n  splice(start: number, deleteCount: number, ...items: Player[]): Player[];\r\n  splice(start: number, deleteCount?: number, ...items: Player[]): Player[] {\r\n    if (deleteCount === void 0) {\r\n      return super.splice(start);\r\n    }\r\n    const filtered = items.filter(item => !this.items.some(existingItem => this.compareEntities(existingItem, item)));\r\n    return super.splice(start, deleteCount, ...filtered);\r\n  }\r\n}", "import {\r\n  Dimension,\r\n  Entity,\r\n  InputPermissionCategory,\r\n  Player,\r\n  Vector3,\r\n} from \"@minecraft/server\";\r\n\r\nexport enum InputPermission {\r\n  Movement = \"movement\",\r\n  Camera = \"camera\",\r\n}\r\nexport enum CameraShakeType {\r\n  Positional = \"positional\",\r\n  Rotational = \"rotational\",\r\n}\r\nexport enum SlotLocation {\r\n  Armor = \"slot.armor\",\r\n  Body = \"slot.armor.body\",\r\n  ArmorChest = \"slot.armor.chest\",\r\n  Feet = \"slot.armor.feet\",\r\n  Head = \"slot.armor.head\",\r\n  Legs = \"slot.armor.legs\",\r\n  Chest = \"slot.chest\",\r\n  EnderChest = \"slot.enderchest\",\r\n  Equippable = \"slot.equippable\",\r\n  Hotbar = \"slot.hotbar\",\r\n  Inventory = \"slot.inventory\",\r\n  Saddle = \"slot.saddle\",\r\n  MainHand = \"slot.weapon.mainhand\",\r\n  OffHand = \"slot.weapon.offhand\",\r\n}\r\n\r\nexport type Quantity =\r\n  | number\r\n  | {\r\n      min?: number;\r\n      max: number;\r\n    }\r\n  | {\r\n      min: number;\r\n      max?: number;\r\n    };\r\n\r\nexport type ItemMatcher = {\r\n  // these properties are always allowed\r\n  item?: string;\r\n  quantity?: Quantity;\r\n  data?: number;\r\n  slotLocation?: SlotLocation;\r\n  slot?: number;\r\n} & // if slot is specified, slotLocation must also be defined\r\n(| { slot?: undefined; slotLocation?: SlotLocation }\r\n  | { slot: number; slotLocation: SlotLocation }\r\n);\r\n\r\n/**\r\n * This is a collection of utility methods for working with commands until a proper API is available.\r\n * Once a proper API is available and stable, I'll change function to use that instead and mark it as deprecated.\r\n */\r\nexport class CommandUtils {\r\n  /**\r\n   * Sets the input permission for a player.\r\n   * @param player The player for whom to set the input permission.\r\n   * @param permission The input permission to set.\r\n   * @param value The value to set the input permission to.\r\n   *\r\n   * @deprecated Use `player.inputPermissions.setPermissionCategory` instead.\r\n   */\r\n  public static setInputPermission(\r\n    player: Player,\r\n    permission: InputPermission,\r\n    value: boolean\r\n  ): void {\r\n    player.inputPermissions.setPermissionCategory(\r\n      permission === InputPermission.Movement\r\n        ? InputPermissionCategory.Movement\r\n        : InputPermissionCategory.Camera,\r\n      value\r\n    );\r\n  }\r\n  /**\r\n   * Adds camera shake effect to the specified player.\r\n   * @param player - The player to apply the camera shake effect to.\r\n   * @param type - The type of camera shake effect.\r\n   * @param intensity - The intensity of the camera shake effect.\r\n   * @param duration - The duration of the camera shake effect in seconds.\r\n   */\r\n  public static addCameraShake(\r\n    player: Player,\r\n    type: CameraShakeType,\r\n    intensity: number,\r\n    duration: number\r\n  ): void {\r\n    player.runCommand(\r\n      `camerashake add @s ${intensity.toFixed(20)} ${duration.toFixed(\r\n        20\r\n      )} ${type}`\r\n    );\r\n  }\r\n  /**\r\n   * Stops the camera shake for the specified player.\r\n   * @param player The player for whom to stop the camera shake.\r\n   */\r\n  public static stopCameraShake(player: Player): void {\r\n    player.runCommand(`camerashake stop @s`);\r\n  }\r\n  /**\r\n   * Destroys the block as if it's broken by a player.\r\n   * @param dimension The dimension in which to destroy the block.\r\n   * @param location The location of the block to destroy.\r\n   */\r\n  public static destroyBlock(dimension: Dimension, location: Vector3): void {\r\n    dimension.runCommand(\r\n      `setblock ${location.x} ${location.y} ${location.z} air destroy`\r\n    );\r\n  }\r\n  /**\r\n   * Checks if an entity have items matching the specified matchers.\r\n   * @param entity The entity to check.\r\n   * @param matchers The matchers to check.\r\n   * @returns True if the entity has items matching the matchers, false otherwise.\r\n   * \r\n   * @remarks\r\n   * This method uses the `testfor` command and `hasitem` selector, so that you can check for the data of the item.\r\n   */\r\n  public static isItem(entity: Entity, matchers: ItemMatcher[]): boolean {\r\n    let cmd = `testfor @s[hasitem=[`;\r\n    for (let i = 0; i < matchers.length; i++) {\r\n      const matcher = matchers[i];\r\n      cmd += `{item=${matcher.item}`;\r\n      if (matcher.quantity !== void 0) {\r\n        cmd += \",quantity=\";\r\n        if (typeof matcher.quantity === \"number\") {\r\n          cmd += matcher.quantity;\r\n        } else {\r\n          if (matcher.quantity.min != void 0) {\r\n            cmd += matcher.quantity.min;\r\n          }\r\n          cmd += \"..\";\r\n          if (matcher.quantity.max != void 0) {\r\n            cmd += matcher.quantity.max;\r\n          }\r\n        }\r\n      }\r\n      if (matcher.data !== void 0) {\r\n        cmd += `,data=${matcher.data}`;\r\n      }\r\n      if (matcher.slotLocation !== void 0) {\r\n        cmd += `,${matcher.slotLocation}=${matcher.slot}`;\r\n        if (matcher.slot !== void 0) {\r\n          cmd += `,slot=${matcher.slot}`;\r\n        }\r\n      }\r\n      cmd += \"}\";\r\n    }\r\n    cmd += ']]';\r\n    const result = entity.runCommand(cmd);\r\n    return result.successCount > 0;\r\n  }\r\n\r\n  /**\r\n   * Pushes a fog to the top of the player's fog stack with the specified user provided ID.\r\n   * @param player The player to push the fog to.\r\n   * @param fogId The ID of the fog to push.\r\n   * @param userProvidedId The user-provided ID of the fog to push.\r\n   * @returns True if the fog was pushed successfully, false otherwise.\r\n   * \r\n   * @remarks\r\n   * This method uses the `fog` command and `push` subcommand.\r\n   */\r\n  public static pushFog(player: Player, fogId: string, userProvidedId: string): boolean {\r\n    return player.runCommand(`fog @s push ${fogId} ${userProvidedId}`).successCount > 0;\r\n  }\r\n\r\n  /**\r\n   * Pops a fog from the top of the player's fog stack matching the specified user provided ID.\r\n   * @param player The player to pop the fog from.\r\n   * @param fogId The ID of the fog to pop.\r\n   * @param userProvidedId The user-provided ID of the fog to pop.\r\n   * @returns True if the fog was popped successfully, false otherwise.\r\n   * \r\n   * @remarks\r\n   * This method uses the `fog` command and `pop` subcommand.\r\n   */\r\n  public static popFog(player: Player, fogId: string, userProvidedId: string): boolean {\r\n    return player.runCommand(`fog @s pop ${fogId} ${userProvidedId}`).successCount > 0;\r\n  }\r\n\r\n  /**\r\n   * Removes all fogs from the player's fog stack matching the specified user provided ID.\r\n   * @param player The player to remove the fog from.\r\n   * @param fogId The ID of the fog to remove.\r\n   * @param userProvidedId The user-provided ID of the fog to remove.\r\n   * @returns True if the fog was removed successfully, false otherwise.\r\n   * \r\n   * @remarks\r\n   * This method uses the `fog` command and `remove` subcommand.\r\n   */\r\n  public static removeFog(player: Player, fogId: string, userProvidedId: string): boolean {\r\n    return player.runCommand(`fog @s remove ${fogId} ${userProvidedId}`).successCount > 0;\r\n  }\r\n}\r\n", "import { Entity, Player, system } from \"@minecraft/server\";\r\n\r\n/**\r\n * Represents a Molang expression. This will be injected into the variable value as Molang expression.\r\n */\r\nexport type MolangExpression = {\r\n  /**\r\n   * The Molang expression to inject.\r\n   */\r\n  value: string\r\n};\r\n\r\n/**\r\n * Represents a Molang value. This can be a number, boolean, or Molang expression.\r\n */\r\nexport type MolangValue = number | boolean | MolangExpression;\r\n\r\n/**\r\n * Sends Molang variables to an entity using `playanimation` command.\r\n * @param entity The entity to send the data to.\r\n * @param animation The RP animation to send the data through.\r\n * @param data The data to send.\r\n * @param receivers Players to send the data to. If not specified, the data will be sent to all players.\r\n */\r\nexport function sendMolangData(entity: Entity, animation: string, data: { [key: string]: MolangValue }, receivers: Player[] = []) {\r\n  data['v.__time__'] = system.currentTick;\r\n  data['v.__random__'] = (Math.random() * 1000) << 0;\r\n  const stopExpression = Object.entries(data).map(([key, value]) => {\r\n    if (typeof value === \"number\") {\r\n      return `${key}=${value}`;\r\n    } else if (typeof value === \"boolean\") {\r\n      return `${key}=${value ? 1 : 0}`;\r\n    } else {\r\n      return `${key}=${value.value}`;\r\n    }\r\n  }).join(\";\") + \";return 0;\";\r\n  entity.playAnimation(animation, {\r\n    stopExpression: stopExpression,\r\n    controller: \"__\" + animation + \"_send_data__\",\r\n    players: receivers.length ? receivers.map(player => player.name) : undefined\r\n  });\r\n}", "export default class VanillaBlockTags {\r\n    public static readonly Acacia = 'acacia';\r\n    public static readonly Birch = 'birch';\r\n    public static readonly DarkOak = 'dark_oak';\r\n    public static readonly DiamondPickDiggable = 'diamond_pick_diggable';\r\n    public static readonly Dirt = 'dirt';\r\n    public static readonly FertilizeArea = 'fertilize_area';\r\n    public static readonly Grass = 'grass';\r\n    public static readonly Gravel = 'gravel';\r\n    public static readonly IronPickDiggable = 'iron_pick_diggable';\r\n    public static readonly Jungle = 'jungle';\r\n    public static readonly Log = 'log';\r\n    public static readonly Metal = 'metal';\r\n    public static readonly Crop = 'minecraft:crop';\r\n    public static readonly DiamondTierDestructible = 'minecraft:diamond_tier_destructible';\r\n    public static readonly IronTierDestructible = 'minecraft:iron_tier_destructible';\r\n    public static readonly IsAxeItemDestructible = 'minecraft:is_axe_item_destructible';\r\n    public static readonly IsHoeItemDestructible = 'minecraft:is_hoe_item_destructible';\r\n    public static readonly IsPickaxeItemDestructible = 'minecraft:is_pickaxe_item_destructible';\r\n    public static readonly IsShearsItemDestructible = 'minecraft:is_shears_item_destructible';\r\n    public static readonly IsShovelItemDestructible = 'minecraft:is_shovel_item_destructible';\r\n    public static readonly IsSwordItemDestructible = 'minecraft:is_sword_item_destructible';\r\n    public static readonly StoneTierDestructible = 'minecraft:stone_tier_destructible';\r\n    public static readonly MobSpawner = 'mob_spawner';\r\n    public static readonly NotFeatureReplaceable = 'not_feature_replaceable';\r\n    public static readonly Oak = 'oak';\r\n    public static readonly OneWayCollidable = 'one_way_collidable';\r\n    public static readonly Plant = 'plant';\r\n    public static readonly Pumpkin = 'pumpkin';\r\n    public static readonly Rail = 'rail';\r\n    public static readonly Sand = 'sand';\r\n    public static readonly Snow = 'snow';\r\n    public static readonly Spruce = 'spruce';\r\n    public static readonly Stone = 'stone';\r\n    public static readonly StonePickDiggable = 'stone_pick_diggable';\r\n    public static readonly TextSign = 'text_sign';\r\n    public static readonly Trapdoors = 'trapdoors';\r\n    public static readonly Water = 'water';\r\n    public static readonly Wood = 'wood';\r\n}", "export default class VanillaItemTags {\r\n    public static readonly Arrow = 'minecraft:arrow';\r\n    public static readonly Banner = 'minecraft:banner';\r\n    public static readonly Boat = 'minecraft:boat';\r\n    public static readonly Boats = 'minecraft:boats';\r\n    public static readonly BookshelfBooks = 'minecraft:bookshelf_books';\r\n    public static readonly ChainmailTier = 'minecraft:chainmail_tier';\r\n    public static readonly Coals = 'minecraft:coals';\r\n    public static readonly CrimsonStems = 'minecraft:crimson_stems';\r\n    public static readonly DecoratedPotSherds = 'minecraft:decorated_pot_sherds';\r\n    public static readonly DiamondTier = 'minecraft:diamond_tier';\r\n    public static readonly Digger = 'minecraft:digger';\r\n    public static readonly Door = 'minecraft:door';\r\n    public static readonly GoldenTier = 'minecraft:golden_tier';\r\n    public static readonly HangingActor = 'minecraft:hanging_actor';\r\n    public static readonly HangingSign = 'minecraft:hanging_sign';\r\n    public static readonly HorseArmor = 'minecraft:horse_armor';\r\n    public static readonly IronTier = 'minecraft:iron_tier';\r\n    public static readonly IsArmor = 'minecraft:is_armor';\r\n    public static readonly IsAxe = 'minecraft:is_axe';\r\n    public static readonly IsCooked = 'minecraft:is_cooked';\r\n    public static readonly IsFish = 'minecraft:is_fish';\r\n    public static readonly IsFood = 'minecraft:is_food';\r\n    public static readonly IsHoe = 'minecraft:is_hoe';\r\n    public static readonly IsMeat = 'minecraft:is_meat';\r\n    public static readonly IsMinecart = 'minecraft:is_minecart';\r\n    public static readonly IsPickaxe = 'minecraft:is_pickaxe';\r\n    public static readonly IsShears = 'minecraft:is_shears';\r\n    public static readonly IsShovel = 'minecraft:is_shovel';\r\n    public static readonly IsSword = 'minecraft:is_sword';\r\n    public static readonly IsTool = 'minecraft:is_tool';\r\n    public static readonly IsTrident = 'minecraft:is_trident';\r\n    public static readonly LeatherTier = 'minecraft:leather_tier';\r\n    public static readonly LecternBooks = 'minecraft:lectern_books';\r\n    public static readonly Logs = 'minecraft:logs';\r\n    public static readonly LogsThatBurn = 'minecraft:logs_that_burn';\r\n    public static readonly MangroveLogs = 'minecraft:mangrove_logs';\r\n    public static readonly MusicDisc = 'minecraft:music_disc';\r\n    public static readonly NetheriteTier = 'minecraft:netherite_tier';\r\n    public static readonly Planks = 'minecraft:planks';\r\n    public static readonly Sand = 'minecraft:sand';\r\n    public static readonly Sign = 'minecraft:sign';\r\n    public static readonly SoulFireBaseBlocks = 'minecraft:soul_fire_base_blocks';\r\n    public static readonly SpawnEgg = 'minecraft:spawn_egg';\r\n    public static readonly StoneBricks = 'minecraft:stone_bricks';\r\n    public static readonly StoneCraftingMaterials = 'minecraft:stone_crafting_materials';\r\n    public static readonly StoneTier = 'minecraft:stone_tier';\r\n    public static readonly StoneToolMaterials = 'minecraft:stone_tool_materials';\r\n    public static readonly TransformMaterials = 'minecraft:transform_materials';\r\n    public static readonly TransformTemplates = 'minecraft:transform_templates';\r\n    public static readonly TransformableItems = 'minecraft:transformable_items';\r\n    public static readonly TrimMaterials = 'minecraft:trim_materials';\r\n    public static readonly TrimTemplates = 'minecraft:trim_templates';\r\n    public static readonly TrimmableArmors = 'minecraft:trimmable_armors';\r\n    public static readonly VibrationDamper = 'minecraft:vibration_damper';\r\n    public static readonly WarpedStems = 'minecraft:warped_stems';\r\n    public static readonly WoodenSlabs = 'minecraft:wooden_slabs';\r\n    public static readonly WoodenTier = 'minecraft:wooden_tier';\r\n    public static readonly Wool = 'minecraft:wool';\r\n}", "export default class TimeOfDay {\r\n  public static readonly Day = 1000;\r\n  public static readonly Midnight = 18000; \r\n  public static readonly Night = 13000;\r\n  public static readonly Noon = 6000;\r\n  public static readonly Sunrise = 23000;\r\n  public static readonly Sunset = 12000;\r\n}", "import { Direction } from \"@minecraft/server\";\r\n\r\nexport default class DirectionUtils {\r\n    /**\r\n     * The opposite directions of the given directions.\r\n     */\r\n    public static readonly Opposites: Record<Direction, Direction> = {\r\n        [Direction.Down]: Direction.Up,\r\n        [Direction.Up]: Direction.Down,\r\n        [Direction.North]: Direction.South,\r\n        [Direction.South]: Direction.North,\r\n        [Direction.East]: Direction.West,\r\n        [Direction.West]: Direction.East,\r\n    };\r\n\r\n    /**\r\n     * The positive perpendicular directions of the given directions.\r\n     */\r\n    public static readonly PositivePerpendiculars: Record<Direction, Direction[]> = {\r\n        [Direction.Down]: [Direction.East, Direction.North],\r\n        [Direction.Up]: [Direction.East, Direction.North],\r\n        [Direction.North]: [Direction.East, Direction.Up],\r\n        [Direction.South]: [Direction.East, Direction.Up],\r\n        [Direction.East]: [Direction.North, Direction.Up],\r\n        [Direction.West]: [Direction.North, Direction.Up],\r\n    };\r\n\r\n    /**\r\n     * The negative perpendicular directions of the given directions.\r\n     */\r\n    public static readonly NegativePerpendiculars: Record<Direction, Direction[]> = {\r\n        [Direction.Down]: [Direction.West, Direction.South],\r\n        [Direction.Up]: [Direction.West, Direction.South],\r\n        [Direction.North]: [Direction.West, Direction.Down],\r\n        [Direction.South]: [Direction.West, Direction.Down],\r\n        [Direction.East]: [Direction.South, Direction.Down],\r\n        [Direction.West]: [Direction.South, Direction.Down],\r\n    };\r\n\r\n    /**\r\n     * All directions.\r\n     */\r\n    public static readonly Values: Direction[] = [\r\n        Direction.Down,\r\n        Direction.Up,\r\n        Direction.North,\r\n        Direction.South,\r\n        Direction.East,\r\n        Direction.West,\r\n    ];\r\n}", "import { RGBA } from \"@minecraft/server\";\r\n\r\nexport default class ColorUtils {\r\n  /**\r\n   * Parse hex string to RGBA. Hex string can be in format AARRGGBB or RRGGBB. Can be prefixed with # or 0x. Can also be a number.\r\n   * @param hex color\r\n   * @returns RGBA color\r\n   */\r\n  public static toRGBA(hex: string): RGBA;\r\n  /**\r\n   * Parse color to RGBA. Number can be in format AARRGGBB or RRGGBB. \r\n   * @param hex color\r\n   * @returns RGBA color\r\n   */\r\n  public static toRGBA(hex: number): RGBA;\r\n  /**\r\n   * Parse red, green and blue to RGBA. All numbers must be between 0 and 255.\r\n   * @param r red\r\n   * @param g green\r\n   * @param b blue\r\n   * @returns RGBA color\r\n   */\r\n  public static toRGBA(r: number, g: number, b: number): RGBA;\r\n  /**\r\n   * Parse red, green, blue and alpha to RGBA. All numbers must be between 0 and 255.\r\n   * @param r red\r\n   * @param g green\r\n   * @param b blue\r\n   * @param a alpha\r\n   * @returns RGBA color\r\n   */\r\n  public static toRGBA(r: number, g: number, b: number, a: number): RGBA;\r\n  public static toRGBA(hex: string | number, g?: number, b?: number, a?: number): RGBA {\r\n    if (typeof hex === \"number\") {\r\n      if (g !== void 0 && b !== void 0) {\r\n        return {\r\n          red: hex / 255.0,\r\n          green: g / 255.0,\r\n          blue: b / 255.0,\r\n          alpha: a === void 0 ? 1 : a / 255.0,\r\n        };\r\n      }\r\n      const hasAlpha = hex > 0xffffff;\r\n      return {\r\n        red: ((hex & 0xff0000) >> 16) / 255.0,\r\n        green: ((hex & 0xff00) >> 8) / 255.0,\r\n        blue: (hex & 0xff) / 255.0,\r\n        alpha: hasAlpha ? ((hex & 0xff000000) >>> 24) / 255.0 : 1,\r\n      };\r\n    }\r\n    if (hex.startsWith(\"#\")) {\r\n      hex = hex.substring(1);\r\n    } else if (hex.startsWith(\"0x\")) {\r\n      hex = hex.substring(2);\r\n    }\r\n    let alpha = 1;\r\n    if (hex.length === 8) {\r\n      alpha = parseInt(hex.substring(0, 2), 16) / 255.0;\r\n      hex = hex.substring(2);\r\n    }\r\n    return {\r\n      red: parseInt(hex.substring(0, 2), 16) / 255.0,\r\n      green: parseInt(hex.substring(2, 4), 16) / 255.0,\r\n      blue: parseInt(hex.substring(4, 6), 16) / 255.0,\r\n      alpha: alpha,\r\n    };\r\n  }\r\n}\r\n", "import { Dimension, Entity, StructureSaveMode, world } from \"@minecraft/server\";\r\nimport Vec3 from \"../Vec3\";\r\nimport { getDimensionHeightRange } from \"../Cache\";\r\n\r\nexport default class EntitySaver {\r\n  /**\r\n   * Saves an entity to the structure.\r\n   * @param entity The entity to save.\r\n   * @param prefix The prefix to use for the structure.\r\n   * @param removeEntity Whether to remove the entity after saving.\r\n   * @returns The ID of the structure without the prefix.\r\n   */\r\n  public static save(\r\n    entity: Entity,\r\n    prefix: string,\r\n    removeEntity: boolean = true\r\n  ): number {\r\n    // Find a free ID\r\n    let id = (Math.random() * 1000000 + 1) << 0;\r\n    const structureManager = world.structureManager;\r\n    let i = 0;\r\n    while (structureManager.get(prefix + id)) {\r\n      id = (Math.random() * 1000000 + 1) << 0;\r\n      i++;\r\n      if (i > 1000) {\r\n        // Should NEVER happen\r\n        throw new Error(\"Failed to find a free ID\");\r\n      }\r\n    }\r\n    const dimension = entity.dimension;\r\n    const originalLocation = Vec3.from(entity.location);\r\n    const location = originalLocation.setY(getDimensionHeightRange(dimension.id).min);\r\n    // Teleport the entity to the bottom of the world for saving\r\n    entity.teleport(location);\r\n    // Tag the entity for easier identification\r\n    entity.addTag(prefix + id);\r\n    // Create a structure with only entities\r\n    structureManager.createFromWorld(\r\n      prefix + id,\r\n      dimension,\r\n      location,\r\n      location,\r\n      {\r\n        includeBlocks: false,\r\n        includeEntities: true,\r\n        saveMode: StructureSaveMode.World,\r\n      }\r\n    );\r\n    if (removeEntity) {\r\n      // If the entity should be removed, remove it now\r\n      entity.remove();\r\n    } else {\r\n      // Otherwise, teleport the entity back to its original location\r\n      entity.teleport(originalLocation);\r\n    }\r\n    return id;\r\n  }\r\n  /**\r\n   * Loads an entity from the structure.\r\n   * @param id The ID of the structure without the prefix.\r\n   * @param prefix The prefix used for the structure.\r\n   * @param dimension The dimension to load the entity in.\r\n   * @param location The location to load the entity at.\r\n   * @param removeStructure Whether to remove the structure after loading.\r\n   * @returns The loaded entity, or undefined if the entity was not found.\r\n   */\r\n  public static load(\r\n    id: number,\r\n    prefix: string,\r\n    dimension: Dimension,\r\n    location: Vec3,\r\n    removeStructure: boolean = true\r\n  ): Entity | undefined {\r\n    const structureManager = world.structureManager;\r\n    // Find the structure\r\n    const structure = structureManager.get(prefix + id);\r\n    if (!structure) {\r\n      return undefined;\r\n    }\r\n    // Set place location at the bottom of the world\r\n    const placeLocation = location.setY(getDimensionHeightRange(dimension.id).min);\r\n    // Place the structure\r\n    structureManager.place(structure, dimension, placeLocation, {\r\n      includeBlocks: false,\r\n      includeEntities: true,\r\n    });\r\n    // Find the entity\r\n    const entities = dimension.getEntities({\r\n      location: placeLocation,\r\n      tags: [prefix + id],\r\n      closest: 1,\r\n    });\r\n    if (entities.length === 0) {\r\n      return undefined;\r\n    }\r\n    const entity = entities[0];\r\n    // Clean tag id\r\n    entity.removeTag(prefix + id);\r\n    // Teleport the entity back to its original location\r\n    entity.teleport(location);\r\n    if (removeStructure) {\r\n      // If the structure should be removed, remove it now\r\n      structureManager.delete(prefix + id);\r\n    }\r\n    return entity;\r\n  }\r\n  /**\r\n   * Removes all structures with the specified prefix.\r\n   * @param prefix The prefix to remove.\r\n   */\r\n  public static clean(prefix: string) {\r\n    const structureManager = world.structureManager;\r\n    structureManager\r\n      .getWorldStructureIds()\r\n      .filter((id) => id.startsWith(prefix))\r\n      .forEach((id) => {\r\n        structureManager.delete(id);\r\n      });\r\n  }\r\n}\r\n", "import { EntityEquippableComponent, EquipmentSlot, GameMode, ItemDurabilityComponent, ItemEnchantableComponent, Player } from \"@minecraft/server\";\r\nimport { Logger } from \"../Logging\";\r\n\r\nconst log = Logger.getLogger(\"itemUtils\", \"bedrock-boost\", \"itemUtils\");\r\n\r\nexport interface ConsumeDurabilityOptions {\r\n  /**\r\n   * Whether to ignore enchantments when consuming durability.\r\n   */\r\n  ignoreEnchantments?: boolean;\r\n  /**\r\n   * Whether to ignore player's gamemode and consume durability anyways.\r\n   */\r\n  ignoreCreative?: boolean;\r\n  /**\r\n   * The amount of durability to consume. Defaults to 1.\r\n   */\r\n  value?: number;\r\n  /**\r\n   * The slot to consume durability from. Defaults to the player's main hand.\r\n   */\r\n  slot?: EquipmentSlot;\r\n  /**\r\n   * Whether to suppress playing a sound when item breaks. Defaults to \"random.break\". If set to an empty string, no sound will be played.\r\n   */\r\n  breakSound?: string;\r\n}\r\n\r\nexport class ItemUtils {\r\n  /**\r\n   * Consumes durability from the player's selected item.\r\n   * @param player - The player whose item durability will be consumed.\r\n   * @param options - The options for consuming durability.\r\n   * @param options.ignoreEnchantments - Whether to ignore enchantments when consuming durability. Defaults to true.\r\n   * @param options.value - The amount of durability to consume. Defaults to 1.\r\n   * @param options.slot - The slot to consume durability from. Defaults to the player's selected slot.\r\n   * @param options.breakSound - Whether to suppress playing a sound when item breaks. Defaults to \"random.break\". If set to an empty string, no sound will be played.\r\n   * @returns True if the durability was consumed, false otherwise.\r\n   * \r\n   * @remarks \r\n   * Return value `false` does not always mean that the function failed. It can also mean that the item was not damaged due to unbreaking enchantment.\r\n   */\r\n  public static consumeDurability(player: Player, options: ConsumeDurabilityOptions = {}): boolean {\r\n    // Compare player's game mode as a string to handle both V1 and V2\r\n    if (!options.ignoreCreative && player.getGameMode().toLowerCase() === 'creative') {\r\n      return false;\r\n    }\r\n    if (options.value === void 0) {\r\n      options.value = 1;\r\n    }\r\n    if (options.slot === void 0) {\r\n      options.slot = EquipmentSlot.Mainhand;\r\n    }\r\n    if (options.breakSound === void 0) {\r\n      options.breakSound = 'random.break';\r\n    }\r\n    if (options.value < 1 || !player) {\r\n      log.error(\"Invalid value or player\");\r\n      return false;\r\n    }\r\n    const equippable = player.getComponent(EntityEquippableComponent.componentId) as EntityEquippableComponent;\r\n    if (!equippable) {\r\n      log.error(\"Player equippable component not found\");\r\n      return false;\r\n    }\r\n    const item = equippable.getEquipment(options.slot);\r\n    if (!item) {\r\n      log.debug(\"No item in selected slot\");\r\n      return false;\r\n    }\r\n    const durabilityComponent = item.getComponent(ItemDurabilityComponent.componentId) as ItemDurabilityComponent;\r\n    if (!durabilityComponent) {\r\n      log.error(\"Item has no durability component\");\r\n      return false;\r\n    }\r\n    if (!options.ignoreEnchantments) {\r\n      const enchantable = item.getComponent(ItemEnchantableComponent.componentId) as ItemEnchantableComponent;\r\n      if (enchantable) {\r\n        const unbreakingLevel = enchantable.getEnchantment('unbreaking')?.level ?? 0;\r\n        if (ItemUtils.getUnbreakingChance(unbreakingLevel) < Math.random()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    if (durabilityComponent.damage + options.value >= durabilityComponent.maxDurability) {\r\n      log.trace(\"Item is broken\");\r\n      equippable.setEquipment(options.slot, undefined);\r\n      if (options.breakSound.length > 0) {\r\n        player.playSound(options.breakSound);\r\n      }\r\n      return true;\r\n    }\r\n    durabilityComponent.damage = durabilityComponent.damage + options.value;\r\n    log.trace(`Item durability is now ${durabilityComponent.damage}/${durabilityComponent.maxDurability}`);\r\n    equippable.setEquipment(options.slot, item);\r\n    return true;\r\n  }\r\n  /**\r\n   * Returns the chance to consume durability from item based on the unbreaking level.\r\n   * @param unbreakingLevel - The unbreaking level of the item.\r\n   * @returns The chance to consume durability from item based on the unbreaking level.\r\n   */\r\n  public static getUnbreakingChance(unbreakingLevel: number) {\r\n    if (unbreakingLevel === 0) {\r\n      return 1;\r\n    }\r\n    return 1 / (unbreakingLevel + 1);\r\n  }\r\n}\r\n\r\n/**\r\n * Consumes durability from the player's selected item.\r\n * @param player - The player whose item durability will be consumed.\r\n * @param value - The amount of durability to consume. Defaults to 1.\r\n * @param slot - The slot to consume durability from. Defaults to the player's selected slot.\r\n * @returns True if the durability was successfully consumed, false otherwise.\r\n * \r\n * @deprecated Use `ItemUtils.consumeDurability` instead.\r\n */\r\nexport function consumeDurability(player: Player, value: number = 1, slot: EquipmentSlot = EquipmentSlot.Mainhand): boolean {\r\n  return ItemUtils.consumeDurability(player, {\r\n    slot,\r\n    value,\r\n    // These settings are set so that the function will work the same way as before\r\n    ignoreEnchantments: true,\r\n    breakSound: '',\r\n    ignoreCreative: true,\r\n  });\r\n}", "import { Entity } from \"@minecraft/server\";\r\nimport Vec3 from \"../Vec3\";\r\n\r\nexport interface EntityHitbox {\r\n    bound: Vec3;\r\n    location: Vec3;\r\n}\r\n\r\nexport class EntityUtils {\r\n    /**\r\n     * Finds the hitbox dimensions and base corner location of an entity.\r\n     * @param entity The target entity.\r\n     * @param maxWidth Maximum search width (default: 5 blocks).\r\n     * @param maxHeight Maximum search height (default: 5 blocks).\r\n     * @returns Object with hitbox size (`bound`) and corner location (`location`).\r\n     */\r\n    static findEntityHitbox(\r\n        entity: Entity,\r\n        maxWidth: number = 5,\r\n        maxHeight: number = 5\r\n    ): EntityHitbox {\r\n        const { location: { x, y, z }, dimension } = entity;\r\n\r\n        const getRaycastHitDistance = (\r\n            ox: number, oy: number, oz: number,\r\n            dx: number, dy: number, dz: number,\r\n            maxDistance: number\r\n        ): number => {\r\n            const rayHit = dimension\r\n                .getEntitiesFromRay(\r\n                    { x: ox, y: oy, z: oz },\r\n                    { x: dx, y: dy, z: dz },\r\n                    { maxDistance, ignoreBlockCollision: true, type: entity.typeId }\r\n                )\r\n                .find((res) => res.entity === entity);\r\n\r\n            return rayHit ? maxDistance - rayHit.distance : 0;\r\n        };\r\n\r\n        const height = getRaycastHitDistance(x, y + maxHeight, z, 0, -1, 0, maxHeight);\r\n        const yMid = y + (height ? height / 2 : 0);\r\n\r\n        const width = getRaycastHitDistance(x - maxWidth, yMid, z, 1, 0, 0, maxWidth);\r\n        const length = getRaycastHitDistance(x, yMid, z - maxWidth, 0, 0, 1, maxWidth);\r\n\r\n        return {\r\n            bound: Vec3.from(width * 2, height, length * 2),\r\n            location: Vec3.from(x - width, y, z - length),\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": "AAAA,OAAS,SAAAA,MAAa,oBCAtB,OAAkB,aAAAC,MAA0B,0EAmpC1C,OAKA,UAAeC,MAAA,oBASf,OAKW,oBAAAC,EAAA,SAAAC,MAAA,oBAgBX,OAAA,SAAAC,MAAA,oBAAA,OAAA,UAAAC,OAAA,oBA0LI,OAAA,UAAMC,OAAyB,oBMt1CnC,OAAO,UAAAC,MAAsB,oBIgGnB,OAAA,UACOC,EAAK,SAAAC,MAAA,oBE5FtB,OAAA,UAAAC,EAAA,UAAAC,EAAA,SAAAC,MAAA,oBA0EA,OAEQ,2BAAAC,OAA+B,oBGrDnB,OACpB,UAAAC,OAAA,oBCsBE,OAAA,aAAiBC,MAAa,oBC2E1B,OACF,qBAAAC,GAAA,SAAAC,OAAA,oBE5I4B,OACP,6BAAAC,GAA0B,iBAAAC,GAAA,2BAAAC,GAAA,4BAAAC,OAAA,kCjBXtB,YAAAC,EAAAC,EAAA,CAAA,KAAA,KAAAD,EAAA,KAAA,MAAAC,EA6M3BA,IAAoB,KAAA,EAAAA,GAAA,GAAA,IAAsB,KAAA,EAAAA,GAAA,EAAA,IACtC,KAAI,EAAOA,EAAA,IAEP,CAGR,OAAA,MAAA,IAAAC,EAAA,IAAA,CAAA,EAAA,OAAA,UAAA,IAAAA,EAAA,IAAA,GAAA,EA/MqE,OAAA,WAAA,IAAAA,EAAA,IAAA,KAAA,EAII,OAAA,UAAA,IAAAA,EAAA,IAAA,KAAA,EAIzE,OAAuB,SAAwB,IAAIA,EAAU,IAAK,QAAQ,EAAA,OAAA,YAAA,IAAAA,EAAA,IAAA,QAAA,EAID,OAAA,KAAA,IAAAA,EAAA,IAAA,QAAA,EAID,OAAA,KAAA,IAAAA,EAAA,IAAA,QAAA,EAIxE,OAAuB,UAAyB,IAAIA,EAAU,IAAK,OAAQ,EAAA,OAAA,KAAA,IAAAA,EAAA,IAAA,OAAA,EAIP,OAAA,MAAA,IAAAA,EAAA,IAAA,OAAA,EAIA,OAAA,KAAA,IAAAA,EAAA,IAAA,OAAA,EAIpE,OAAuB,IAAA,IAAuBA,EAAI,IAAU,QAAK,EAAQ,OAAA,aAAA,IAAAA,EAAA,IAAA,QAAA,EAIL,OAAA,OAAA,IAAAA,EAAA,IAAA,QAAA,EAIC,OAAA,MAAA,IAAAA,EAAA,IAAA,QAAA,EAIrE,OAAuB,cAAsB,IAAUA,EAAa,IAAA,QAAA,EAAA,OAAA,gBAAA,IAAAA,EAAA,IAAA,QAAA,EAID,OAAA,cAAA,IAAAA,EAAA,IAAA,QAAA,EAIS,OAAA,mBAAA,IAAAA,EAAA,IAAA,OAAA,EAI5E,OAAuB,kBAAkC,IAAAA,EAAa,IAAA,OAAA,EAAA,OAAA,gBAAA,IAAAA,EAAA,IAAA,QAAA,EAID,OAAA,cAAA,IAAAA,EAAA,IAAA,QAAA,EAIQ,OAAA,iBAAA,IAAAA,EAAA,IAAA,OAAA,EAI7E,OAAuB,iBAAiC,IAAAA,EAAe,IAAA,OAAQ,EAAA,OAAA,eAAA,IAAAA,EAAA,IAAA,OAAA,EAIF,OAAA,kBAAA,IAAAA,EAAA,IAAA,QAAA,EAIK,OAAA,WAAA,IAAAA,EAAA,GAAA,EAIlF,OAAuB,KAAA,IAAAA,EAAmC,GAAA,EAAuB,OAAA,OAAA,IAAAA,EAAA,GAAA,EAIF,OAAA,MAAA,IAAAA,EAAA,GAAA,EAIF,OAAA,OAAA,CAAAA,EAAA,MAAAA,EAAA,UAI7EA,EAAuB,WAAyDA,EAAA,UAAAA,EAAA,SAAAA,EAAA,YAIhFA,EAAuB,KAAyDA,EAAA,KAAAA,EAAA,UAAAA,EAAA,KAIhFA,EAAuB,MAAuDA,EAAA,KAAAA,EAAA,IAAAA,EAAA,aAI9EA,EAAuB,OAA0DA,EAAA,MAAAA,EAAA,cAAAA,EAAA,gBAIjFA,EAAuB,cAAyCA,EAAA,mBAAAA,EAAA,kBAAAA,EAAA,gBAIhEA,EAAuB,cAAmCA,EAAA,iBAAAA,EAAA,iBAAAA,EAAA,eAI1DA,EAAuB,kBAAqCA,EAAA,WAAAA,EAAA,KAAAA,EAAA,OAI5DA,EAAuB,KAAoC,EAK3D,OAAuB,WAAsB,CACzCA,EAAU,MACVA,EAAU,UACVA,EAAU,WACVA,EAAU,UACVA,EAAU,SACVA,EAAU,YACVA,EAAU,KACVA,EAAU,KACVA,EAAU,UACVA,EAAU,KACVA,EAAU,MACVA,EAAU,KACVA,EAAU,IACVA,EAAU,aACVA,EAAU,OACVA,EAAU,MACVA,EAAU,cACVA,EAAU,gBACVA,EAAU,cACVA,EAAU,mBACVA,EAAU,kBACVA,EAAU,gBACVA,EAAU,cACVA,EAAU,iBACVA,EAAU,iBACVA,EAAU,eACVA,EAAU,iBAAA,EACA,EACA,EACA,EAEd,OAAA,OAAA,OAQI,UAAU,CACV,OAAAA,EAAU,OAAA,KAAA,IAAA,CAKV,OAAA,CACA,OAAA,KAAU,KAAA,CAKV,OAAA,CACA,OAAA,KAAU,OAAA,SAAA,EAAA,CAAA,CAMV,QAAU,CACV,OAAA,KAAU,CAAA,CAON,UAAA,CACA,OAAA,KAAA,CACA,CAkByB,SAAA,CAAA,OAAA,KAAA,CAAA,CASjC,SAAA,CAAA,OAAA,KAAA,IAAA,CAQA,OAAA,WAAAC,EAAA,CAAA,OAAAA,EAAA,QAAA,aAAA,EAAA,CAAA,CAQA,OAAA,iBAAAC,EAAAC,EAAAC,EAAA,CAAA,IAAAC,EAAA,OAAA,UAAAC,EAAAN,EAAA,MAOO,QAA6BD,KAAAC,EAAA,WAChC,GAAAD,EAAY,GAAAA,EAAA,GAAAA,EAAA,EAAA,CAChB,IAAAQ,EAAA,KAAA,KAAA,KAAA,IAAAR,EAAA,EAAAG,EAAA,CAAA,EAAA,KAAA,IAAAH,EAAA,EAAAI,EAAA,CAAA,EAAA,KAAA,IAAAJ,EAAA,EAAAK,EAAA,CAAA,CAAA,EAAAG,EAAAF,IAAAA,EAAAE,EAAAD,EAAAP,EAAA,CAQI,OAAOO,CACX,CAAA,EAAAE,EAAA,MAAAC,CAAA,CAAA,WAAA,IAAA,YAAA,IAQO,UAA8B,IACjC,WAAO,IACX,MAAA,IAAA,kBAAA,IAAA,gBAAA,IAAA,aAAA,GAAA,OAAA,KAAA,QAAA;EAOO,MAAA,IAEP,gBAAA,GAAA,SAAA,EAAA,kBAAA,GAOA,cAAO,SACH,UAAO,OACX,eAAA,YAAA,UAAA,OAAA,WAAA,QAAA,WAAA,gBAAA,qBAAA,QAAA,qBAAAC,EAAA,OAAA,oBAAAA,EAAA,KASA,YAAOA,EAAiB,UACpB,YAAIA,EAAc,WAClB,aAAIA,EAA0B,KAC9B,UAAAA,EAAoB,KAChB,SAAIA,EAAW,KACX,YAAMA,EAAW,KACjB,cAAIA,EAAW,KACX,WAAAA,EAAc,KACd,WAAAA,EAAe,KAAA,WACnBA,EAAA,SAGR,OAAO,QAAA,IAAAD,EACX,OAAA,aAAA,CACJ,IAAAE,EAAA,IAAAF,4DClTqBE,EAAA,YAAA,GAAUA,EAAA,YAAA,GAEpBA,EAAA,aAAqB,GACrBA,EAAA,UAAsB,GACtBA,EAAA,SAAoB,GACpBA,EAAA,YAAqB,GACrBA,EAAgB,cAAA,GAChBA,EAAA,WAA4B,GAC5BA,EAAA,WAA0B,GAC1BA,EAAA,WAAuB,GACNA,CACjB,CAIA,OAAA,MAA0B,KAAA,YAAA,EAI1B,UAAAC,EAA6B,CAAA,OAAA,KAAA,eAAAA,EAAA,CAG7B,YAAwB,EACxB,QAAoB,IAAA,OACpB,CAAA,CACA,CAG+B,gBAAAA,EAAA,CAG/B,OAAA,KAAA,YAA2C,KAAU,gBAAA,KAAA,aAAAA,CAAA,EAAA,KAAA,gBAAAF,EAAA,KACrD,CAIA,gBAAgCE,EAAU,CAC1C,OAAA,KAA+B,YAAUA,EAAA,SAAA,EAAAF,EAAA,KACzC,CAIA,iBAAiCE,EAAU,CAAA,OAAA,KAAA,cAAAA,EAAA,KAAA,UAAA,KAAA,YAAAF,EAAA,KAAA,CAS9C,kBAAME,EAAA,CACN,OAAM,KAAA,cAAsB,KAAA,cAAAF,EAAA,KAC5B,CAGA,eAAkB,CAClB,OAAM,KAAA,UAAW,KAAA,UAAAA,EAAA,KACjB,CAGA,oBAAmB,CACnB,OAAM,KAAA,UAAa,KAAA,eAAAA,EAAA,KACnB,CACJ,gBAAA,CAAA,OAAA,KAAA,WAAA,KAAA,WAAAA,EAAA,KAKA,CAMO,eAAkCE,EAAAC,EAAA,CACrC,IAAAC,EAAY,KAAA,OAAe,OAAOD,EAAA,WAAA,EAAA,GAC9BD,EAAA,SAAa,EACb,OAAA,KAAS,oBAAI,KAAa,UAAA,KAAA,WAAAF,EAAA,MAElC,IAAAK,EAAA,KAAA,oBAAA,KAAA,UAAAL,EAAA,MAAA,KAAA,QAAAM,EAAA,KAAA,oBAAA,KAAA,UAAAN,EAAA,MASA,OATAE,EAAA,QAAA,CAAAK,EAAAC,IAAA,CAAAH,GAAAD,EAAA,KAAA,OAAA,KAAA,eAAAG,EAAA,KAAA,OAAAJ,CAAA,CAAA,EAAAE,GAAAG,EAAAN,EAAA,OAAA,EAAA,KAAA,MAAA,KAAA,QAAA,KAAA,QAMUI,GAAgB,KAAuB,eAAAC,EAAA,KAAA,OAAAJ,CAAA,CAAA,EAE7CG,GAAYE,EAAcN,EAAK,OAAA,EAAA,KAAkB,MAAK,KAAA,MAAkB,EAC5E,CAAA,EAAAG,GAAAD,EAAA,KAAA,oBAAA,KAAA,WAAAJ,EAAA,MAAAM,GAAA,KAAA,oBAAA,KAAA,WAAAN,EAAA,MAAAM,EAAA,OAAA,KAAA,gBAAAA,EAQWD,CACX,CAQI,yBAAYH,EAAgBO,EAAaN,EAAA,CAC7C,OAAA,KAAA,kBAAA,KAAA,WAAA,GAAA,KAAA,WAAAM,EAAAT,EAAA,MAAA,KAAA,MAAA,IAAA,KAAA,oBAAA,CAUA,gBAAAE,EAAAO,EAAAC,EAAAP,EAAA,CAAA,IAAAC,EAAA,KAAA,OAAA,OAAAD,EAAA,WAAA,EAAAQ,EAAA,KAAA,mBAAAF,IAAA,SAAA,KAAA,WAAA,GAAA,KAAA,WAAAA,EAAAT,EAAA,MAAA,KAAA,MAAA,GAAA,GAAAU,EAAA,SAAA,EAKU,OAAAC,EAAwB,KAAA,qBAAA,KAAA,WAAA,KAAA,YAAAX,EAAA,MAGlC,IAAAK,EAAAM,EAAA,KAAA,qBAAA,KAAA,WAAAX,EAAA,MAAA,KAAA,QAAAM,EAAAK,EAAA,KAAA,qBAAA,KAAA,WAAAX,EAAA,MAcI,OAdJU,EAAA,QAAA,CAAA,CAAAE,EAAAC,CAAA,EAAAL,IAAA,CAAA,IAAAM,EAAA,KAAA,eAAAD,EAAA,KAAA,OAAAV,CAAA,CAAA,EAKUE,GAAAD,EAA6B,KAAA,OAAA,KAAA,SAAA,KAAA,aAAAQ,EAAA,KAAA,aAAAZ,EAAA,MAAA,KAAA,kBAAA,KAAA,MAAAc,EAEnCT,GAAYG,EAAAE,EAAY,OAAK,EAAA,KAAiB,MAAA,KAAU,QAAA,KAAA,QAC5DJ,GAAA,KAAA,SAAAM,EAAAZ,EAAA,MAAA,KAAA,kBAAA,KAAA,MAAAc,EAAAR,GAAAE,EAAAE,EAAA,OAAA,EAAA,KAAA,MAAA,KAAA,MAAA,EAAA,CAAA,EAAAL,GAAAD,EAAA,KAAA,qBAAA,KAAA,YAAAJ,EAAA,MAKUM,GAAyB,KAAA,qBAAA,KAAA,YAAAN,EAAA,MAC/BM,EAAY,OAAa,KAAK,gBAClCA,EAAAD,CAAA,CAAA,qBAAAH,EAAAO,EAAAN,EAAA,CAAA,MAAA,EAAAM,IAAA,UAAAN,EAAA,aAAA,KAAA,UAAA,KAAA,UAAA,EAOU,CAMN,eAAaD,EAAKC,EAAA,CAClB,GAAID,IAAA,KAAgB,OAAK,KAAA,cAAA,EACzB,GAAAA,IAAc,OAAO,OAAA,KAAU,mBAAA,EAC3B,GAAA,OAAAA,GAAU,SAAmB,OAAA,KAAS,gBAAKA,CAAe,EAC1D,GAAA,OAAAA,GAAmB,SAAM,OAAS,KAAI,gBAAkBA,CAAA,EAExD,GAAA,OAAAA,GAAiB,UAAK,OAAe,KAAA,iBAAsBA,CAAA,EAC3D,GAAA,OAAAA,GAAkB,WAAc,OAAA,KAAS,kBAAiBA,CAAK,EACnE,GAAC,KAAA,QAAAA,EAAAC,CAAA,EACD,OAAA,KAAU,eAAmB,EAKzB,GADJ,KAAI,UAAAD,EAAcC,CAAA,EACd,MAAO,QAAAD,CAAA,EAAA,CACX,IAAAG,EAAA,KAAA,eAAAH,EAAAC,EAAA,YAAA,KAAA,OAAAA,CAAA,EAAAA,CAAA,EACA,YAAO,WAAAD,EAAAC,CAAA,EACXE,CAAA,CAAA,GAAA,OAAAH,GAAA,SAAA,CAAA,IAAAa,EAAAb,EAAA,YAAA,KAAA,GAAA,KAAA,qBAAAA,EAAAa,EAAAZ,CAAA,EA4CQ,CACA,IAAOE,EAAA,KAAA,yBAAAH,EAAAa,EAAAZ,CAAA,EACX,YAAA,WAAAD,EAAAC,CAAA,EACOE,CACX,KAhDA,CAAA,IAAAW,EAAA,IAAA,IAAAC,EAAA,OAAA,eAAAf,CAAA,EAQUgB,EAAA,OAAA,KAAyBD,CAAe,EAC9C,KAAQC,EAAK,OAAA,GACjBA,EAAA,QAAAN,GAAAI,EAAA,IAAAJ,CAAA,CAAA,EAAAK,EAAA,OAAA,eAAAA,CAAA,EAAAC,EAAA,OAAA,KAAAD,CAAA,EAAA,OAAA,KAAAf,CAAA,EAAA,QAAAU,GAAAI,EAAA,IAAAJ,CAAA,CAAA,EAAAI,EAAA,OAAA,oBAAA,EAUI,IAAMN,EAVV,CAAA,GAAAM,CASU,EAAA,KAAA,EACmB,IAAOJ,GAAO,CACjC,GAAA,CAEF,MAAQ,CACDA,EACXV,EAAAU,CAAA,GAAA,MAEI,CACA,MAAA,CAGI,MAAA,CACEA,EACN,MACA,CAEA,CACA,CAAA,EAAA,OAAA,CAAA,CAAA,CAAAC,CAAkB,IAAA,OAAQA,GAAQ,YAAmBA,IAAQ,MAAK,EACrER,EAAA,KAAA,gBAAAH,EAAAa,EAAAL,EAAAP,CAAA,EAED,YAAA,WAAUD,EAAcC,CAAK,EAC7BE,CAGA,CAMM,CACN,YAAA,WAASH,EAAcC,CAAA,EAC3BH,EAAA,MAAAE,EAAA,SAAA,CAAA,CAAA,aAAAX,EAAA,CAOU,OAAAA,EAAA,QAAe,MAAsC,KAAA,YAAA,OAAA,KAAA,WAAA,EAAA,QAAA,KAAA,KAAA,YAAA,MAAA,KAAA,WAAA,EAAA,QAAA,MAAA,KAAA,YAAA,MAAA,KAAA,WAAA,EAAA,QAAA,MAAA,KAAA,YAAA,MAAA,KAAA,WAAA,EAAA,QAAA,MAAA,KAAA,YAAA,MAAA,KAAA,WAAA,CAE3D,CAAoB,UAAAW,EAAYC,EAAA,CAChCA,EAAI,QAAA,IAAUD,CAAA,CAAQ,CACtB,QAAIA,EAAOC,EAAA,CAAoB,OAAAA,EAAO,QAAK,IAAAD,CAAA,CAC3C,CAA+B,WAAOA,EAAKC,EAAA,CAC3CA,EAAI,QAAO,OAAAD,CAAU,CAAW,CAChC,OAAIC,EAAA,CAA6B,MAAA,CAGjC,GAAIA,EACA,YAAYA,EAAA,YAAe,CAC/B,CACA,CAGA,EAEIgB,EAAK,OACL,GAAA,CAAOA,EACX,mBAGA,MAAI,CAAA,CAYQ,IAAAC,EAAA,MAAAC,CAAmB,CAUnB,YAAIC,EAAAC,EAAAC,EAAAC,EAAA,MAAA,CACA,KAAA,MAAAH,EAA0C,KAAA,KAC9CC,EACI,KAAA,MAAAC,CAAmB,CACvB,OACH,IAAE,IAAQH,EAAM,GAAM,KAAO,EAC9B,OAAA,MAAM,IAAAA,EAAc,GAAA,QAAgBI,EAAO,SAAM,EACjD,OAAA,MAAK,IAAAJ,EAAkB,GAAG,QAAAI,EAAA,IAAA,EAC1B,OAAA,KAAO,IAAAJ,EAAA,EAAA,OAAAI,EAAA,KAAA,EAAA,OACX,KAAO,IAAAJ,EAAA,EAAA,OAAAI,EAAA,IAAA,EACH,OAAA,MAAM,IAAAJ,EAAc,EAAA,QAAAI,EAAyB,GAAA,EAC7C,OAAA,MAAK,IAAAJ,EAAkB,EAAG,QAAAI,EAAA,QAAA,EAC1B,OAAA,IAAO,IAAAJ,EAAA,IAAA,KAAA,EAGf,OAAK,OAAW,CAGhBA,EAAO,IACXA,EAAA,MAAAA,EAAA,MAAAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,MAMUA,EAAA,MACNA,EAAO,GAKX,EAOI,UAAW,CACf,OAAA,KAAA,MAAA,KAAA,KAAA,YAAA,EAAAI,EAAA,KAEQ,CAOZ,OAAA,MAAAC,EAAA,yCFpUI,GAAAJ,EAAA,OAAqBI,EAAA,OAAAJ,EAEvB,IAAAK,EAAA,SAAgBD,CAAA,EAClB,GAAA,CAAS,MAAGC,CAAA,GAEZ,QAAAL,KAAAD,EAAA,OAKY,GAAAC,EAAL,QAAAK,EAAA,OAAKC,EAgBVA,CAhBU,EAAA,SAAAC,EAAAC,EAAAJ,EAAA,CAsBL,OAAMI,IAAN,IAAM,GAASA,EAAA,SAAA,GAAA,EAAAA,EAAA,WAAA,GAAA,EAAAJ,EAAA,SAAAI,EAAA,UAAA,CAAA,CAAA,EAAAA,EAAA,SAAA,GAAA,EAAAJ,EAAA,WAAAI,EAAA,UAAA,EAAAA,EAAA,OAAA,CAAA,CAAA,EAgCF,IACA,OACTA,EAAmB,QAAU,MACpC,IAAA,CAAA,EAHgB,KAAAJ,CAAA,EAETI,IAAAJ,CAAA,CACN,IAlCHK,EAA2B,CAC3B,MAAOX,EAAkB,KACzB,OAAO,CACP,GACA,EACA,WAAO,GACP,eAAyB,CAAAE,EAAIU,EAAYC,EAASC,EAAA,SAAU,CAC5D,IAAOC,EAAgBD,IAAI,OAAc,QAAKA,EAAA,IAAAE,GAAA,IAAAA,CAAA,GAAA,EAAA,KAAA,EAAA,CAAA,QAAA,GAAA,MAAA,IAAAd,CAAA,KAAAG,EAAA,gBAAA,GAAAO,EAAA,IAAA,GAAAP,EAAA,KAAA,IAAAU,CAAA,IAAAF,CAAA,EAAA,EAAA,qBAAAI,GAKvCA,EAAS,KAAA,GAAA,EACL,cACAC,EAAA,QAAA,aACA,CACT,CAAAlB,EAAS,MAAA,KAAA,EAAA,CACT,EACA,CACA,EACA,CAAAA,EAAS,MAAA,KAAA,EAAA,CACX,EAAA,CAAA,EAAA,CAAAA,EAAA,KAAA,KAAA,EAAA,CAAA,EAAA,CAoBO,EACL,CAAAA,EAAO,KAAK,KAAQ,EAAA,CACtB,EAAA,EAAA,CAAA,EAAA,CAAAA,EAAA,MAAA,KAAA,EAAA,CAAA,EAAA,EAQA,CACE,EACA,CAAAA,EAAA,MAAW,KAAS,EAAA,CAClB,EAAwB,EAC1B,CAEA,CACA,CACE,EACEmB,EAAI,MAAMC,CAAA,CAKlB,YAAAjB,EAAAW,EAAA,CAAA,EAAA,CAiBA,KAAS,KAAAX,EACP,KAAI,KAAAW,CAAiB,CACrB,OAAI,YAAiB,GAGnB,OAAA,MAAA,CAEEM,EAAW,cACbA,EAAA,YAAA,GACAC,EAAM,YAAY,mBAAe,UAAeC,GAAK,CACrD,GAAOA,EAAA,KAAW,iBAAGA,EAAA,KAAA,YACvB,GAAA,CAAAA,EAAA,QACOX,EAAY,MAAAX,EAAA,KACrBuB,EAAA,YAAA,GAAAlB,EAAA,IAAA,wBAAAA,EAAA,IAAA,GAAAM,EAAA,KAAA,EAAA,MAiBM,CACG,IAAST,EAAAF,EAAA,MAAAsB,EAAA,OAAA,EACJpB,GACAS,EAAA,MAAAT,EACZqB,EACE,YACA,GACAlB,EACA,IAAA,wBACGA,EAAA,IAAA,GAAAM,EAAA,KAAA,EAAA,GAGIY,EAAS,YAAK,GAAUlB,EAAA,QAAgB,0BAA2BiB,EAAA,OAAS,EAAA,CAErF,MACSA,EAAS,KAAQ,kBAAAA,EAAA,KAAA,gBAC1BA,EAAA,QAKGX,EAAuB,OAAAW,EAAA,QAAiB,MAAA,GAAA,EAJ3CX,EAAyB,OAAA,CACzB,GACG,EAICY,EAAA,YAAA,GAAAlB,EAAA,IAAA,yBAAAA,EAAA,IAAA,GAAAM,EAAA,OAAA,KAAA,IAAA,CAAA,EAAA,EAEA,CAAA,EACF,CAIE,OAAA,SAAAT,EAAA,CACFS,EAAA,MAAAT,CAAA,CAKA,OAAA,UAAAsB,EAAA,CACFb,EAAA,OAAAa,CACF,CAKoB,OAAA,kBAAAC,EAAA,CAAAd,EAAA,eAAAc,CAAA,CAoH8B,OAAA,wBAAAA,EAAA,CAAsBd,EAAA,qBAAAc,CAnHtE,CAIA,OAAO,wBAAOC,EAAA,CACZf,EAAS,WAAAe,CACP,CAGE,OAAI,iBAAUC,EAAmB,CAC/BhB,EAAQ,cAASgB,CACf,CAGA,OACF,iBAAO,CACL,OAAAhB,EAAc,YACd,CAO6D,OAAA,UAC3DR,KAAAW,EAAA,CACF,OACFM,EAAA,aACFA,EAAA,KAAW,EAGT,IAAAA,EAAOjB,EAAAW,CAAA,CACL,CAQN,IAACZ,KAAAW,EAAA,CAEL,GAAA,EAAAX,EAAA,MAAAS,EAAA,MAAA,OAAA,IAAAA,EAAA,OAAA,SAAA,GAAA,KAAA,KAAA,SAAA,EAAA,CAAA,KAAA,OAAAT,EAAA,GAAAW,CAAA,EAAA,MAIA,CACE,QAAAW,KAAgBb,EAAQ,OAAA,CAC1B,GAAAa,EAAA,WAAA,GAAA,IAAAf,EAAAe,EAAA,UAAA,CAAA,EAAA,KAAA,IAAA,GAAA,KAAA,KAAA,KAAAR,GAAAP,EAAAe,EAAA,UAAA,CAAA,EAAAR,CAAA,CAAA,GAAA,OAKA,GAAOP,EAAUe,EAAwB,KAAA,IAAA,GAAA,KAAA,KAAA,KAAAR,GAAAP,EAAAe,EAAAR,CAAA,CAAA,EAAA,CACvC,KAAA,OAAgBd,EAAS,GAAAW,CAAA,EAC3B,MAAA,CAAA,EAAA,CAKA,eAAOe,EAAA,CAGL,IAAAC,EAAAD,EAAA,OAAgB,GAClB,GAAAE,EAAA,CAAA,IAAAC,EAAA,mCAAAF,EAAAA,EAAA,MAAA;CAAA,EAAA,IAAAG,GAAA,CAAA,IAAAC,EAAAF,EAAA,KAAAC,CAAA,EAAA,GAAAC,EAAA,CAKO,IAAAC,EAAAD,EAAwB,CAAA,EAC7BE,EAAgB,SAAAF,EAAuB,CAAA,EAAA,EAAA,EAAAH,EAAA,SAAA,OACzC,GAAAI,EAAA,SAAAJ,EAAA,SAAA,QAAA,EAAA,CAAA,IAAAM,EAAA,oBAAAD,CAAA,EAAA,GAAAC,EAAA,CAAA,IAAAC,EAAA,IAAAD,EAAA,MAAA,IAAAA,EAAA,YAAA,IAAA,OAAAJ,EAAA,QAAAD,EAAAM,CAAA,CAKO,CACL,CACF,CAAA,OAAAL,CAAA,CAAA,EAAA,KAAA;CAAA,CAAA,CAAA,MAAA,GAAA3B,EAAA,QAAA,GAAAA,EAAA,IAAA,GAAAuB,EAAA,OAAA;EAKAvB,EAAO,KAAA,GAAAA,EAAiB,IAAA,GAAsBA,EAAA,MAAA,GAAAwB,CAAA,GAAAxB,EAAA,KAAA,EAC5C,CAMF,OAAOH,KAAAW,EAAgC,CAC9B,CACT,IAAAyB,EAAAzB,EAAA,IAAAe,GAAAA,IAAA,OAAAvB,EAAA,KAAA,YAAAA,EAAA,MAAAuB,IAAA,KAAAvB,EAAA,KAAA,OAAAA,EAAA,MAAAuB,GAAAA,aAAA,MAAA,KAAA,eAAAA,CAAA,EAUE,OAASA,GAAA,UAAA,MAAA,QAAAA,CAAA,EACFjB,EAAoB,cAAA,UAAAiB,CAAA,EAAAvB,EAAA,MAEzBuB,EAAA,SAAA,EAAAvB,EAAA,KACF,EACOkC,EAAW5B,EAAU,eAAAT,EAAA,KAAAS,EAAA,qBAAA2B,CAAA,EAAA3B,EAAA,WAAA,KAAA,KAAA,MAAA,EAC9B6B,EAAA7B,EAAA,aAAAT,EAAA,KAAA,GAAA,CAAA,EAAA,CAAA,EAAA,GAAAsC,EAAA,SAAA,CAAA,EAAA,GAAA,CAAAjB,EAAA,YAAAgB,CAAA,CAeY,MAAoB,CAC9BlB,EAAS,IAAA,IAAA,CACHE,EAAM,YAAQgB,CAAA,CAA6B,CAAA,CAC/C,CAEEC,EAAA,SAAA,CAAA,IACF,QAAA,YACA,QAAW,YAAUnC,EAAA,WAAwBkC,CAAA,CAAA,EAEzC,QACE,IAAAlC,EAAiB,WAAWkC,CAAQ,CAAA,GAKxCC,EAAA,SAAA,CAAA,GACA,QACE,KAAAD,CAAkB,EAIlBC,EAAA,SAAA,CAAA,GACF,QAAA,MAAAD,CAAA,CAEJ,CACF,CAaI,SAAQ1B,EACL,CAEC,KAAM,IAAQb,EAAA,MAAe,GAAAa,CAAS,CACtC,CAKI,SAAAA,EAAI,CAGF,KAAA,IAAMb,EAAA,MAAkB,GAAAa,CAAA,CACxB,CAKR,QACMA,EAAI,CACd,KAAA,IAAAb,EAAA,KAAA,GAAAa,CAAA,CAEA,CACF,QAAAA,EAAA,CAAA,KAAA,IAAAb,EAAA,KAAA,GAAAa,CAAA,CAAA,CAWM,SAAIA,EAAM,CACR,KAAO,IAAAb,EAAU,MAAO,GAAAa,CAAc,CAAU,CAMhD,SAAAA,EAAY,CACd,KAAA,IAAAb,EAAA,MAAA,GAAAa,CAAA,CACA,CACE,EAEF4B,EAAA,MAASC,CAAA,CAAuB,OACjC,IAAAvB,EAAA,UAAA,OAAA,OAAA,eAAA,EAEC,OACA,KAAA,IAAAuB,EAAA,EAAA,EAAA,CAAA,EAGF,OAAA,KAAA,IAAAA,EAAAC,EAAA,IAAA,EAEE,OACA,GAAA,IAAAD,EAAAC,EAAA,EAAA,EAGA,OAAI,MAAA,IAAAD,EAAAC,EAAA,KAAA,EAGF,OAAA,MAAW,IAAAD,EAAMC,EAAA,KAAA,EAEhB,OACH,KAAA,IAAAD,EAAAC,EAAA,IAAA,EAGA,OAAK,KAAgB,IAAAD,EAAAC,EAAa,IAAA,EAChC,EAA4D,EAE5D,EAA2C,YAC7Cf,EAAAgB,EAAAC,EAAA,CAAA,GACFjB,IAAAe,EAAA,KACA,KAAI,EAAA,EACF,KAAA,EAAA,GACF,KAAA,EAAA,UACIf,IAAQe,EAAS,GACnB,KAAA,EAAA,EACF,KAAA,EAAA,EACF,KAAA,EAAA,UACFf,IAAAe,EAAA,MAAA,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,WAAAf,IAAAe,EAAA,MAAA,KAAA,EAAA,EAOA,KAAS,EAAA,EACP,KAAA,EAAA,UAAkBf,IAAAe,EAAgB,KACpC,KAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,UAAAf,IAAAe,EAAA,KAAA,KAAA,EAAA,GAAA,KAAA,EAAA,EAOA,KAAS,EAAA,UACP,OAAAf,GAAA,SAAS,KAAK,EAAIA,EACpB,KAAA,EAAAgB,EAAA,KAAA,EAAAC,UAAA,MAAA,QAAAjB,CAAA,EAAA,KAAA,EAAAA,EAAA,CAAA,EAAA,KAAA,EAAAA,EAAA,CAAA,EAAA,KAAA,EAAAA,EAAA,CAAA,UAOQA,aAAoBc,EAC1B,KAAA,EAAAd,EAAA,EAAS,KAAK,EAAIA,EAAA,EACpB,KAAA,EAAAA,EAAA,MAAA,CAAA,GAAA,CAAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,EAAA,MAAAc,EAAA,IAAA,MAAA,IAAA,MAAA,gBAAA,EAAAd,CAAA,EAAA,IAAA,MAAA,gBAAA,EAOA,KAAQ,EAAAA,EAAA,EACN,KAAA,EAAAA,EAAA,EAAS,KAAK,EAAIA,EAAA,CACpB,CAAA,CAAA,OAAA,KAAAA,EAAAgB,EAAAC,EAAA,CAAA,GAAAjB,aAAAc,EAAA,OAAAd,EAAA,GAAA,OAAAA,GAAA,UAAAgB,IAAA,QAAAC,IAAA,OAAA,OAAA,IAAAH,EAAAd,EAAAgB,EAAAC,CAAA,EAQE,GAAA,MAAA,QAAAjB,CAAA,EAAS,OAAK,IAAIc,EAAAd,CAAS,EAC7B,GAAAA,IAAAe,EAAA,KAAA,OAAAD,EAAA,KAAA,GAAAd,IAAAe,EAAA,GAAA,OAAAD,EAAA,GAAA,GAAAd,IAAAe,EAAA,MAAA,OAAAD,EAAA,MAAA,GAAAd,IAAAe,EAAA,MAAA,OAAAD,EAAA,MAAA,GAAAd,IAAAe,EAAA,KAAA,OAAAD,EAAA,KAOA,GAAAd,IAASe,EAAoB,KAAA,OAAAD,EAAA,KAC3B,GAAA,CAAAd,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,EAAS,MAAAc,EAAK,IAAI,MAAA,IAAS,MAAO,mBAAU,EAAAd,EAAAgB,EAAAC,CAAA,EAC9C,IAAA,MAAA,mBAAA,4BDreF,OAAqB,MAArBjB,EAAqBgB,EAAAC,EAAwB,CAC3C,GAAAjB,aAA8Bc,EAAO,OAAAd,EACnC,GAAA,OAAAA,GAAA,UAAAgB,IAAA,QAAAC,IAAA,OACA,OAAA,IAAAH,EAAAd,EAAAgB,EAAAC,CAAA,EAEF,GAAA,MAAA,QAAAjB,CAAA,EAAA,OAAA,IAAAc,EAAAd,CAAA,EAAA,GAAAA,IAAAe,EAAA,KAAA,OAAAD,EAAA,KAIA,GAAAd,IAAuBe,EAAW,GAAK,OAAOD,EAAA,GAAA,GAAAd,IAAAe,EAAA,MAAA,OAAAD,EAAA,MAAA,GAAAd,IAAAe,EAAA,MAAA,OAAAD,EAAA,MAAA,GAAAd,IAAAe,EAAA,KAAA,OAAAD,EAAA,KAI9C,GAAAd,IAAuBe,EAAW,KAAK,OAAUD,EAAI,KAAA,GAAA,CAAAd,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,GAAA,CAAAA,EAAA,GAAAA,EAAA,IAAA,EAAA,MAAAc,EAAA,IAAA,MAAA,IAAA,MAAA,mBAAA,EAAAd,EAAAgB,EAAAC,CAAA,EAAA,IAAA,MAAA,mBAAA,EAIJ,OAAA,IAAAH,EAAAd,EAAA,EAAAA,EAAA,EAAAA,EAAA,CAAA,CAAA,CAIM,MAAA,CAIvD,OAAuB,IAAAc,EAAY,KAAA,EAAK,KAAA,EAAU,KAAK,CAAA,CAAA,CAAA,OAAA,aAAAI,EAAAC,EAAA,CAAA,IAAAC,EAIvD,OAAuBF,GAAgB,UAAcE,EAAAF,EAAAC,EAAAA,IAIrDC,EAAuBF,EAAgB,EAE9BC,EAAAD,EAAA,GAEA,IAAAG,EAAAD,GAAA,KAAA,GAAA,KAMTE,EAA2BH,GAAwB,KAAA,GAAA,KAC7CnB,EAAM,KAAA,IAAAsB,CAAU,EAAM,KAAA,IAAAD,CAAA,EACxBL,EAAK,KAAI,IAAAM,CAAA,EACTL,EAAK,KAAI,IAAAK,CAAA,EAAA,KAAA,IAAAD,CAAA,EACT,OAAK,IAAIP,EAAAd,EAAAgB,EAAAC,CAAA,CAAA,CAET,OAAA,aAASC,EAAAC,EAAA,CACT,IAAAC,EACA,OAASF,GAAA,UACXE,EAAAF,EACEC,EAAKA,IAELC,EAAKF,EAAI,EACXC,EAAAD,EAAiB,GAEf,IAAAG,EAASD,GAAA,KAAA,GAAA,KACTE,EAASH,GAAA,KAAA,GAAA,KACXnB,EAAA,CAAW,KAAA,IAAMsB,CAAA,EAAU,KAAM,IAAAD,CAAA,EAC/BL,EAAK,CAAI,KAAA,IAAAM,CAAA,EACTL,EAAK,KAAI,IAAAK,CAAA,EAAA,KAAA,IAAAD,CAAA,EACT,OAAK,IAAIP,EAAAd,EAAAgB,EAAAC,CAAA,CAAA,CAOT,YAAS,CACT,GAAA,KAAK,OAAI,EACX,MAAAH,EAAA,IAAW,MAAM,IAAA,MAAS,gDAAG,CAAA,EACtB,IAAI,MAAG,gDAAA,EAEZ,IAAAS,EAAY,KAAA,UAAA,EACdH,EAAW,KAAA,MAAAG,EAAmB,EAAAA,EAAA,CAAA,GAAA,IAAA,KAAA,IAE5B,MAAK,CACL,EAFW,KAAA,KAAAA,EAAA,CAAA,GAAA,IAAA,KAAA,IAGb,EAAAH,CACE,CAME,CAKF,YAAW,CACb,GAAA,KAAA,OAAA,EACF,MAAAN,EAAA,IAAA,MAAA,IAAA,MAAA,gDAAA,CAAA,EASO,IAAK,MAA2B,gDAAkB,EAChC,IAAAS,EAAO,KAAA,UAAA,EAC1BH,EAAO,CAAA,KAAM,MAAAG,EAAY,EAAMA,EAAa,CAAA,GAAM,IAAW,KAAA,IAEjE,MAAA,CACA,EAFa,KAAK,KAAG,CAAGA,EAAC,CAAA,GAAA,IAAA,KAAA,IAGvB,EAAAH,CACF,CACA,CAA0B,IAAApB,EAAAgB,EAAAC,EAAO,CACjC,IAAIO,EAAMV,EAAA,MAAUd,EAAAgB,EAAAC,CAAA,EAAI,OAAAH,EAAO,KAAKU,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,CAAA,CACpC,CAA2B,SAAAxB,EAAOgB,EAAAC,EAAK,CACvC,IAAIO,EAAMV,EAAA,MAAUd,EAAAgB,EAAAC,CAAA,EAAO,OAAAH,EAAO,KAAK,KAAA,EAAAU,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,CAAA,CACvC,CAA0B,SAAAxB,EAAOgB,EAAAC,EAAK,CACtC,GAAI,OAAMjB,GAAA,UAAUgB,IAAA,QAAAC,IAAA,OAAM,OAAOH,EAAK,KAAA,KAAA,EAAAd,EAAA,KAAA,EAAAA,EAAA,KAAA,EAAAA,CAAA,EAOpC,IAAAwB,EAAKV,EAAI,MAAUd,EAAAgB,EAAMC,CAAA,EACzB,OAAAH,EAAU,KAAMU,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAmB,KAAA,EAAAA,EAAA,EAAA,KAAA,CAAA,CAAA,CAOvC,MAAAC,EAAA,CACA,OAAeX,EAAM,KAA2B,KAAkB,EAAAW,EAAA,KAAA,EAAAA,EAAA,KAAA,EAAAA,CAAA,CAChE,CAAuB,OAAAzB,EAAAgB,EAAOC,EAAA,CAC9B,GAAI,OAAOjB,GAAM,UAAYgB,IAAM,QAAaC,IAAM,OAAW,CAC/D,GAAAjB,IAAO,EAAI,MAAK,IAAM,MAAC,uBAAA,EACzB,OAAAc,EAAA,KAAA,KAAA,EAAAd,EAAA,KAAA,EAAAA,EAAA,KAAA,EAAAA,CAAA,CACA,CACE,IAAAwB,EAAOV,EAAI,MAAMd,EAAAgB,EAAAC,CAAA,EACnB,GAAAO,EAAA,IAAA,GAAAA,EAAA,IAAA,GAAAA,EAAA,IAAA,EAAA,MAAA,IAAA,MAAA,uBAAA,EACA,OAAIV,EAAM,KAAA,KAAU,EAAAU,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,CAAA,CAAM,CAGC,WAAO,CAClC,GAAI,KAAA,OAAM,EAAgB,MAAAV,EAAA,IAAO,MAAK,IAAA,MAAA,qCAAA,CAAA,EAClC,IAAM,MAAA,qCAAU,EACpB,IACGY,EACE,KAAU,OAAgB,EAI7B,OAAAZ,EAAS,KAAM,KAAI,EAAAY,EAAM,KAAA,EAAAA,EAAA,KAAsB,EAAGA,CAAI,CACtD,CAKC,QAAU,CACb,OAAA,KAAA,MAAA,KAAA,EAAA,KAAA,EAAA,KAAA,CAAA,CACF,CAMA,eAAa,CACX,OAAO,KAAI,EAAA,KAAK,EAAQ,KAAK,EAAG,KAAM,EAAA,KAAA,EAAA,KAAA,CACxC,CAkBA,MAAA1B,EAAOgB,EAAAC,EAAA,CACL,IAAIO,EAAAV,EAAA,MAAAd,EAAAgB,EAAAC,CAAA,EACJ,OAAIH,EAAO,KAAA,KAAA,EAAAU,EAAkB,EAAA,KAAA,EAAUA,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,CAAA,CACrC,CACA,SAAAxB,EAAQgB,EAAAC,EAAA,CACV,IAAAO,EAAOV,EAAA,MAAAd,EAAAgB,EAAAC,CAAA,EACL,OAAA,KAAM,SAAAO,CAAc,EAAA,OAAA,CACpB,CAAsB,gBACxBxB,EAAAgB,EAAAC,EAAA,CAEA,IAAMO,EAAAV,EAAM,MAAOd,EAAKgB,EAAAC,CAAK,EAC7B,OAAM,KAAA,SAAQO,CAAA,EAAS,cAAU,CAEjC,CAwBE,KAAAA,EAAMG,EAAA,CACN,MAAA,CAAAH,GAAQ,CAAAG,EAAAb,EAAA,KAAA,IAAA,EACVa,IAAO,EAAAb,EAAA,KAAAU,CAAA,EACLG,IAAM,EAAAb,EAAc,KAAA,IAAA,EACpBA,EAAQ,KAAA,KAAA,GAAcU,EAAA,EAAA,KAAA,GAAAG,EAAA,KAAA,GAAAH,EAAA,EAAA,KAAA,GAAAG,EAAA,KAAA,GAAAH,EAAA,EAAA,KAAA,GAAAG,CAAA,CAAA,CAU1B,MAAAH,EAAAG,EAAA,CAAA,GAAA,CAAAH,GAAA,CAAAG,EAAA,OAAAb,EAAA,KAAA,IAAA,EAAA,GAAAa,IAAA,EAAA,OAAAb,EAAA,KAAAU,CAAA,EAAA,GAAAG,IAAA,EAAA,OAAAb,EAAA,KAAA,IAAA,EAAA,IAAAc,EAAA,KAAA,IAAAJ,CAAA,EAAAF,EAAA,KAAA,KAAAM,CAAA,EAAAD,EAQAE,EAAsBf,EAAA,KAAAU,CAAA,EAAA,SAAA,KAAA,SAAAI,CAAA,CAAA,EAAA,UAAA,EACpB,OAAI,KAAK,SAAU,KAAA,IAAAN,CAAA,CAAA,EAAA,IAAAO,EAAA,SAAA,KAAA,IAAAP,CAAA,CAAA,CAAA,CACjB,CAAS,IAAAtB,EACPgB,EAAIC,EAAA,CAAsD,IAC5DO,EAAAV,EAAA,MAAAd,EAAAgB,EAAAC,CAAA,EACA,OAAA,KAAU,EAAAO,EAAM,EAAA,KAAA,EAAAA,EAAA,EAAA,KAAA,EAAAA,EAAA,CAAgD,CAElE,aAAMxB,EAAAgB,EAAAC,EAAY,CAClB,IAAMO,EAAAV,EAAM,MAAKd,EAAMgB,EAAAC,CAAA,EACjBa,EAAa,KAAK,IAAAN,CAAA,EACxBO,EAAO,KAAA,cAAA,EAAA,GACLA,IAAG,EACH,MAAG,GAEP,IAAAC,EAAAR,EAAA,cAAA,EAAA,GAAAQ,IAAA,EAAA,MAAA,GAAA,IAAAC,EAAA,KAAA,KAAAF,EAAAC,CAAA,EAAAE,EAAA,KAAA,IAAA,EAAA,KAAA,IAAA,GAAAJ,EAAAG,CAAA,CAAA,EAOA,OAAA,KAAsB,KAAAC,CAAA,CACpB,CACE,YAAKlC,EAAIgB,EAAAC,EAAA,CAAA,IACPO,EAAIV,EAAM,MAAAd,EAAAgB,EAAAC,CAAA,EAAgD,GAC5DO,EAAA,OAAA,EACA,OAAMV,EAAI,KAEZ,IAAMmB,EAAAT,EAAA,IAAYA,CAAA,EAClB,GAAAS,IAAa,EACb,OAAMnB,EAAQ,KACP,IACFqB,EAAA,KAAA,IAAAX,CAAA,EAAAS,EAAA,OACAnB,EAAA,KAAAU,EAAA,EAAAW,EAAAX,EAAA,EAAAW,EAAAX,EAAA,EAAAW,CAAA,CAAA,CAEP,QAAAnC,EAAAgB,EAAAC,EAAA,CA2CA,IAAmBmB,EAA8BtB,EAAA,MAAAd,EAAAgB,EAAAC,CAAA,EACzCoB,EAAU,KAAK,YAAaD,CAAA,EAClC,OAAO,KAAA,SAAYC,EAAI,SAAU,CAAA,CAAA,CACnC,CAqGI,OAAOC,EAAKC,EAAK,CACnB,IAAAC,EAAAD,EAAA,KAAA,GAAA,IAAA,EACME,EAAU,KAAA,IAAKD,CAAY,EACjCxC,EAAOsC,EAAK,EAAK,KAAM,IAAAE,CAAU,EACnCxB,EAAAsB,EAAA,EAAA,KAAA,IAAAE,CAAA,EAAAvB,EAAAqB,EAAA,EAAA,KAAA,IAAAE,CAAA,EAAAhB,EAAA,KAAAkB,EAAAD,EAAAA,EAAAjB,EAAA,EAAA,EAAAR,EAAAyB,EAAAjB,EAAA,EAAA,EAAAP,EAAAwB,EAAAjB,EAAA,EAAAxB,EAAAA,EAAAwB,EAAA,EAAA,EAAAR,EAAAhB,EAAAwB,EAAA,EAAA,EAAAP,EAAAjB,EAAAwB,EAAA,EAAAP,EAAAA,EAAAO,EAAA,EAAAR,EAAAA,EAAAQ,EAAA,EAAAmB,EAAA,EAAA3C,EAAAgB,EAAAQ,EAAA,EAAAR,EAAAA,EAAAQ,EAAA,EAAA,EAAAP,EAAAD,EAAAQ,EAAA,EAAA,EAAAiB,EAAAxB,EAAAO,EAAA,EAAAP,EAAAA,EAAAO,EAAA,EAAAiB,EAAAA,EAAAjB,EAAA,EAAA,EAAAxB,EAAAyC,EAAAjB,EAAA,EAAAxB,EAAAA,EAAAwB,EAAA,EAAAoB,EAAA,EAAA5C,EAAAiB,EAAAO,EAAA,EAAA,EAAAR,EAAAC,EAAAO,EAAA,EAAAP,EAAAA,EAAAO,EAAA,EAAA,EAAAiB,EAAAzB,EAAAQ,EAAA,EAAAR,EAAAA,EAAAQ,EAAA,EAAA,EAAAiB,EAAAzC,EAAAwB,EAAA,EAAAxB,EAAAA,EAAAwB,EAAA,EAAAiB,EAAAA,EAAAjB,EAAA,EAAA,OAAA,IAAAV,EAAA4B,EAAAC,EAAAC,CAAA,CAQA,CA0DE,OAAA5C,EAAAgB,EAAAC,EAAA,CACA,OAAAjB,IACAA,EAAM6C,GAAMA,GAEZ7B,IACFA,EAAA6B,GAAAA,GAAA5B,IAAAA,EAAA4B,GAAAA,GAAA,IAAA/B,EAAAd,EAAA,KAAA,CAAA,EAAAgB,EAAA,KAAA,CAAA,EAAAC,EAAA,KAAA,CAAA,CAAA,CAAA,CAQA,KAAA4B,EAAkB,CAChB,OAAI,OAAKA,GAAU,SACZ,IAAI/B,EAAM+B,EAAI,KAAM,EAAA,KAAA,CAAA,EAE3B,IAAA/B,EAAA+B,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA,KAAA,CAAA,CACA,CACA,KAAAA,EAAO,CACT,OAAA,OAAAA,GAAA,SAAA,IAAA/B,EAAA,KAAA,EAAA+B,EAAA,KAAA,CAAA,EAAA,IAAA/B,EAAA,KAAA,EAAA+B,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,CAAA,CAAA,KAAAA,EAAA,CAMA,OAAA,OAAiBA,GAAA,SACR,IAAK/B,EAAM,KAAK,EAAG,KAAK,EAAG+B,CAAM,EAC1C,IAAA/B,EAAA,KAAA,EAAA,KAAA,EAAA+B,EAAA,KAAA,CAAA,CAAA,CAAA,CAiEI,sBAAoBC,EAAMC,EAAA,CAAA,IAC1BC,EAAoBlC,EAAM,KAAAiC,CAAA,EAAA,SAAAD,CAAA,EAAA,GAC1BE,EAAe,cAAW,IAAA,EAC5B,OAAA,KAAA,SAAAF,CAAA,EAAA,OAAA,EA6CF,IAAAnB,EAAwB,KAAY,IAAoB,EAAA,KAAA,IAAA,EAAA,KAAA,SAAAmB,CAAA,EAAA,IAAAE,CAAA,EAAAA,EAAA,IAAAA,CAAA,CAAA,CAAA,EAChDC,EAAenC,EAAS,KAAIgC,CAAA,EAAA,IAAAE,EAAA,SAAArB,CAAA,CAAA,EAClC,OAAO,KAAK,SAASsB,CAAU,EAAA,OAAA,CACjC,CAoDA,OAAA,CAAA,OAAA,KAAA,OAAA,KAAA,MAAA,KAAA,MAAA,KAAA,KAAA,CAAA,CAAA,QAAA,CAAA,OAAA,KAAA,KAAA,KAAA,KAAA,CAAA,CAYE,QAAU,CAAG,OAAA,KAAO,KAAK,KAAM,KAAA,CAC/B,CAGE,QAAK,CAAqB,OACrB,KAAK,KAAE,KAAI,KAAK,CAAK,CAE9B,MAAA,CAAA,OAAA,IAAAnC,EAAA,KAAA,KAAA,KAAA,CAAA,EAAA,KAAA,KAAA,KAAA,CAAA,EAAA,KAAA,KAAA,KAAA,CAAA,CAAA,CAAA,CASA,OAAmC,CACjC,OAAK,KAAM,KAAA,KAAA,IAAA,CAAG,CAED,OAAO,CACpB,OAAM,KAAM,KAAK,KAAK,IAAA,CACtB,CAIA,OAAA,CACF,OAAA,KAAA,KAAA,KAAA,IAAA,CA2CA,CA+CA,OAAA,CACE,OAAM,KAAU,OAAK,KAAM,MAAO,KAAA,MAAA,KAAA,KAAA,CAClC,CAIA,QAAA,CACA,OAAM,KAAA,KAAW,KAAA,KAAA,CACjB,CAKA,QAAM,CACN,OAAO,KAAK,KAAK,KAAA,KAAQ,CAC3B,CAqDI,QAAO,CACT,OAAA,KAAA,KAAA,KAAA,KAAA,CACA,CAIA,IAAM,CACN,OAAO,KAAA,IAAKA,EAAO,EAAI,CACzB,CAoDE,MAAO,CACT,OAAA,KAAA,IAAAA,EAAA,IAAA,CAAA,CAAA,OAAA,CAAA,OAAA,KAAA,IAAAA,EAAA,KAAA,CAAA,CAeE,OAAU,CACV,OAAM,KAAI,IAAKA,EAAI,KAAK,CACxB,CAwBA,MAAM,CAUN,OAAO,KAAI,IAAAA,EAAK,IAAM,CACxB,CAAA,MAAA,CAAA,OAAA,KAAA,IAAAA,EAAA,IAAA,CAAA,CAcE,QAAQ,CACN,OAAK,KAAA,IAAkB,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,CAAA,CAKzB,SAAQ,CACN,MAAK,CACP,KAAA,EACA,KAAO,EACT,KAAA,CASA,CACE,CAIF,aAAA,CASA,GAAK,KAAA,OAA+C,EAClD,MAAAA,EAAI,IAAO,MAAA,IAAU,MAAA,gDAAU,CAAA,EAC7B,IAAO,MAAI,gDAA0B,EAEvC,IAAAoC,EAAgB,KAAK,UAAS,EAChCC,EAAA,KAAA,IAAA,KAAA,IAAAD,EAAA,CAAA,EAAA,KAAA,IAAAA,EAAA,CAAA,EAAA,KAAA,IAAAA,EAAA,CAAA,CAAA,EASA,GAAKC,IAA+CD,EAAA,EAAA,OAAAnC,EAAA,KAClD,GAAIoC,IAAO,CAAAD,EAAU,EAAU,OAAAnC,EAAA,KAC7B,GAAAoC,IAAWD,EAAa,EAAA,OAAQnC,EAAK,GACvC,GAAAoC,IAAA,CAAAD,EAAA,EAAA,OAAAnC,EAAA,KACA,GAAAoC,IAAgBD,EAAQ,EAAK,OAAGnC,EAAa,MAC/C,GAAAoC,IAAA,CAAAD,EAAA,EAAA,OAAAnC,EAAA,MAAA,MAAAD,EAAA,IAAA,MAAA,IAAA,MAAA,oCAAA,EAAA,IAAA,EAAA,IAAA,MAAA,oCAAA,CAAA,CAAA,iBAAA,CAAA,OAAAA,EAAA,MAAA,KAAA,GAAA,IAAA,KAAA,EAAA,GAAA,KAAA,IAAA,KAAA,GAAA,EAAA,EAAA,IAAA,KAAA,GAAA,IAAA,KAAA,EAAA,GAAA,KAAA,IAAA,KAAA,GAAA,EAAA,EAAA,IAAA,KAAA,GAAA,IAAA,KAAA,EAAA,GAAA,KAAA,IAAA,KAAA,GAAA,EAAA,EAAA,EAAA,CAAA,CAAA,YAAAd,EAAAgB,EAAAC,EAAAmC,EAAA,CAAA,GAAA,CAAA,IAAAC,EAYA,OAAA,OAAArD,GAAA,UAAsCiB,IAAsB,QAC1DoC,EAAMvC,EAAA,MAAgBd,EAAA,OAAU,MAAK,EAEjCoD,EAAApC,GAEJqC,EAAAvC,EAAA,MAAAd,EAAAgB,EAAAC,CAAA,EAEE,KAAA,IAAA,KAAA,EAAAoC,EAAA,CAAA,GAAAD,GAAA,KAAA,IAAA,KAAA,EAAAC,EAAA,CAAA,GAAAD,GAAA,KAAA,IAAA,KAAA,EAAAC,EAAA,CAAA,GAAAD,CAAA,MACK,CAAA,MACH,EAAA,CAEiC,CACnC,OACFpD,EAAAgB,EAAAC,EAAA,CACA,GAAA,CACA,IAAOoC,EAAKvC,EAAS,MAAAd,EAAUgB,EAAEC,CAAA,EACnC,OAAA,KAAA,IAAAoC,EAAA,GAAA,KAAA,IAAAA,EAAA,GAAA,KAAA,IAAAA,EAAA,CAAA,MAAA,CAAA,MAAA,EAAA,CAAA,CAcA,SAAAC,EAAA,OAAAC,EAAA,KAAA,CAAA,IAAAC,EAAA,GAAA,KAAA,EAAAD,EAAA,KAAA,EAAAA,EAAA,KAAA,CAAA,GAAA,OAAAD,IAAA,OAAA,QAAAE,CAAA,IAAAA,CAAA,CAYA,OAAe,WAAA9E,EAAA4E,EAAA,OAAAC,EAAA,KAAA,CACb,GAAAD,IAAY,OAAU,CACxB,IAAAjD,EAAA3B,EAAA,MAAA,gBAAA,EAAA,GAAA,CAAA2B,EAAA,MAAA,IAAA,MAAA,uBAAA,EAAA,IAAAoD,EAAApD,EAAA,CAAA,EAAA,MAAAkD,CAAA,EAKA,GAAaE,EAAA,SAAA,EACX,MAAO,IAAI,MAAK,uBAAwB,EAC1C,OAAA3C,EAAA,KAAA,OAAA2C,EAAA,CAAA,CAAA,EAAA,OAAAA,EAAA,CAAA,CAAA,EAAA,OAAAA,EAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,IAAAA,EAAA/E,EAAA,MAAA6E,CAAA,EAAA,GAAAE,EAAA,SAAA,EAKA,MAAc,IAAA,MAAA,uBAAA,EAEd,OAAA3C,EAAA,KAAA,OAAA2C,EAAA,CAAA,CAAA,EAAA,OAAAA,EAAA,CAAA,CAAA,EAAA,OAAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAKAC,EAAc,MAAAC,CAAA,CACZ,OAAA,IAAOpE,EAAU,UAAS,UAAA,SAAA,EAC5B,OAAA,SAAA,GAAA,OAAA,cAAA,GAOA,OAAA,MAAAqE,EAAA,CAAA,KAAA,IAAA,EAAA,KAAA,SAAA,IAAA,KAAA,EAAA,QAAA,EAAA,KAAA,cAAAA,CAKA,CAEA,OAAA,KAAA,CAAA,IAAAC,EAAA,IAAA,KAAA,EAAA,QAAA,EAKA,KAAe,SAAA,GACbF,EAAO,IAAK,MAAK,aAAU,KAAA,aAAA,SAAAE,EAAA,KAAA,QAAA,IAAA,EAC7B,KAAA,SAAA,EAAA,CAAA,EA0CA,SAAAC,EAAAC,EAAA,CAAA,IAAAC,EAAA,OAAA,eAAAD,CAAA,EAAA,QAAA,OAAA,OAAAC,GAAA,WAKaA,EAAA,KAAAD,CAAA,EAEbA,EAAA,OAAA,CA6KI,IAAAE,GAAAC,EAAO,UAAW,WAAW,gBAAiB,UAAU,EMt1C9D,IAAAC,EAAA,MAAAC,CAAA,CAQO,OAAS,IAAAC,EAAA,UAAoB,iBAAyF,gBAAA,iBAAA,EAC3H,MAAM,CAAA,EACN,OAAuB,YAAO,EAC9B,MACF,UAAA,iCEvCA,YAAiBC,EAAuBC,EAAA,+DCUpC,GAAA,CAAOD,GAAO,OAAOA,GAAe,WACxC,MAAA,IAAA,MAAA,qCAAA,EAUI,KAAM,OAAIC,EACV,KAAI,UAAaD,CACb,QDAR,KAAS,KAAAE,CAAA,CACP,CAUE,OAAAC,EAAiB,CACjB,KAAA,KAAA,GAAaA,CAAI,CACnB,CAaG,OAAeC,EAAA,CACdA,GAAA,GAAAA,EAAA,KAAA,MAAA,SAAA,KACK,MAAA,OAAAA,EAAA,CAAqB,EACxBA,EAAG,KAAA,WACL,KAAA,YAEF,KAAA,6BAAA,EAEA,CAaF,SAAMC,EAAiB,CAGvB,QAAIC,EAAA,KAAa,MAAA,OAAA,EAAAA,GAAA,EAAAA,IACbD,EAAa,KAAA,MAAAC,CAAA,CAAA,GACb,KAAA,OAAAA,CAAA,CAGJ,CAKI,UAAA,CAAA,OACK,KAAA,KAAiB,CAIxB,OAAA,CACF,KAAO,KAAA,EACJ,KAAA,YAAe,EAClB,KAAA,UAAA,EACF,KAAA,MAAAC,EAAA,YAAA,IAAA,KAAA,KAAA,EAAA,CAAA,CAEO,CAGL,MAAA,CAEA,KAAO,QAAU,SACfA,EAAA,SAAkB,KAAA,KAAA,EACpB,KAAA,MAAA,uCDlGmB,IAAAC,EAAS,KAAA,MAAA,OAC+C,GAA3E,KAAe,kBAAmC,IAAA,MAAA,KAAI,MAAqB,EAAA,KAAA,CAAA,EAAAA,IAAA,EAAA,OAAA,IAAAC,EAAA,KAAA,OAAAD,EAAA,QAAA,EAAA,EAAA,EAAAA,EAAA,IAM3E,KAAc,kBAAuB,KAAA,MAAAC,EAAA,CAAA,EAAA,KAAA,MAAA,GACC,CACpC,MAAK,CACJ,GAAA,KAAgB,MAAA,SAAc,EAAA,CAC/BX,EAAkB,IAAA,MAAgB,sBAAA,EAC/B,MACD,CACA,IAAAY,EAAyB,KAAA,kBAAA,KAAA,WAAA,EAC3B,GAAAC,IAAA,EAAA,CACFb,EAAA,IAAA,MAAA,gCAAA,EAAA,KAAA,aAAA,KAAA,YAAA,GAAA,KAAA,OAAA,KAAA,cAAA,IAAA,KAAA,UAAA,GAAA,MAAA,CAAA,IAAAc,EAAA,EAQA,KAAc,KAAA,UAAsB,KAAA,MAAA,QAAAA,EAAAD,EAAA,KAAA,YAAA,CAClC,GAAI,CAA+B,KAAA,UAAA,KAAA,MAAA,KAAA,SAAA,CAAA,CACnC,OAAKE,EAAA,CACLf,EAAc,IAAA,MAAA,wBAAAe,CAAA,CAChB,CACFD,sDG/BA,KAAS,cAAAE,IAGH,KAAM,UAAO,EA4BjB,CACE,QAAIA,EAAO,CACT,YAAAA,MAAO,KAAA,GAAOX,CAAA,EACZ,KAAA,6BAAa,EACX,KAAI,MAAA,MACF,CACA,KAAA,CACE,IAAAD,EAAA,KAAQ,MAAe,IAAA,EACvB,YAAA,6BAAA,EAAAA,CAEA,CAAA,OAAA,CACF,IACFA,EAAA,KAAS,MAAK,MAAA,EACZ,YAAA,6BAAU,EACVA,CAAA,CACF,WACFC,EAAA,CAAA,YACC,MAAA,QAAA,GAAAA,CAAA,EACL,KAAA,6BAAO,EACD,KAAM,MAAA,MACV,CACE,OAAAY,EAAMC,EAAY,KAASb,EAAA,CAC3B,IAAAc,EAAO,KAAM,MAAA,OAAAF,EAAAC,EAAA,GAAAb,CAAA,EACX,YAAA,6BAAI,EACFc,CACA,CACE,EAkEF,IAAAC,GAAU,MAAAC,UAAAC,CAAA,CAKlB,YAAOC,EAAAC,EAAAC,EAAA,CACL,MAAIC,GAAA,CACJC,EAAYD,CAAA,EACVH,EAAMG,CAAA,EAEN,KAAA,SAAaE,GAAA,CAAAD,EAAAC,CAAA,CAAA,CAET,EAAAJ,CAAA,EACA,KAAA,aAAOC,EACL,KAAA,KAAA,GAAAI,EAAQ,aAAe,qBAAA,EAAA,YAAA,KAAA,YAAA,CAAA,EACvB,KAAA,KAAA,GAAAA,EAAA,aAAA,kBAAA,EAAA,YAAA,KAAA,YAAA,CAAA,EAAA,KAAA,KACF,GAAAA,EAAO,aAAA,mBAAA,EAAA,YAAA,KAAA,YAAA,CAAA,CAEL,CACE,OAAA,OAAAC,EAAA,UAA4B,uBAAA,gBAAA,wBAAA,EAC5B,gBAAAC,EAAAC,EAAA,CAAe,OAAAD,EAAA,KACjBC,EAAA,EACA,CACE,OAAA,CACAH,EAAA,YAAA,WAAA,UAAAI,GAAA,CAAA,KAAA,sBACFA,EAAA,MAAA,CAAA,CAAA,EACFJ,EACF,YAAS,YAAK,UAAAI,GAAA,CACZ,KAAA,sBAAUA,EAAA,MAAA,CACV,CAAA,EAAAJ,EACF,YAAA,aAAA,UAAAI,GAAA,CAAA,KACF,SAAAL,GAAA,CAAAD,EAAAC,CAAA,GAAAA,EAAA,KAAAK,EAAA,eAAA,CAAA,CAAA,EAEF,MAAI,MAAA,CAAA,0BC1JH,GAAA,CACC,GAAA,CAAAL,EACA,OAEED,EAAQC,CAAA,ECAGA,EAArB,QAAqB,KAAA,YAAkB,GAErC,KAAwB,KAAcA,CAAO,EDD3CM,EAAO,YAAc,IAAM,CAC/BP,EAAAC,CAAA,GAAAA,EAAA,QAAA,KAAA,YAAA,eCTA,EAAS,CAAA,CAWC,OAAA,EAAA,CACAP,EAAsB,OAAA,MAAA,sCAAA,CAAA,CACtB,CACA,CACA,QAAAc,EAAA,CACR,IAAAC,EAAAD,EAAA,OAAAE,GAAAV,EAAAU,CAAA,GAAA,CAAA,KAAA,MAAA,KAAAC,GAAA,KAAA,gBAAAA,EAAAD,CAAA,CAAA,CAAA,EAAA,OAAA,MAAA,KAAA,GAAAD,CAAA,CAAA,CAAA,WAAAD,EAAA,CAAA,IAAAC,EAAAD,EAAA,OAAAE,GAAAV,EAAAU,CAAA,GAAA,CAAA,KAAA,MAAA,KAAAC,GAAA,KAAA,gBAAAA,EAAAD,CAAA,CAAA,CAAA,EAMA,OAAA,MAAY,QAA2B,GAAAD,CAAgB,CACrD,CACE,OAAAG,EAAUC,KAAML,EAAA,CAClB,GAAAK,IAAA,OACA,OAAK,MAAA,OAAaD,CAAO,EAEzB,IAAAH,EAAAD,EAAA,OAAAE,GAAA,CAAA,KAAA,MAAA,KAAAC,GAAA,KAAA,gBAAAA,EAAAD,CAAA,CAAA,CAAA,EACA,OAAK,MAAA,OAASE,EAAAC,EAAA,GAAAJ,CAAA,CACd,CAAiB,EACnBK,GAAA,MAAAC,UAAApB,CAAA,CAAA,OAAA,OAAAQ,EAAA,UAAA,uBAAA,gBAAA,wBAAA,EASA,YAAAP,EAAAC,EAAA,CAAA,MAAAE,GAAA,CAAAC,EAAAD,CAAA,EAAAH,EAAAG,CAAA,EAAA,KAAA,SAAAE,GAAA,CAAAD,EAAAC,CAAA,CAAA,CAQA,EAAAJ,CAAO,EACL,KAAK,KAAK,GAAGmB,EAAK,cAAA,CAAA,CACpB,CAAA,gBAAAZ,EAAAC,EAAA,CAAA,OAAAD,EAAA,KAAAC,EAAA,EAAA,CAAA,OAAA,CAMAW,EAAO,YAAe,WAAA,UAAAV,GAAA,CACpB,IAAIW,EAAS,EACNC,EAAa,IAAA,CAGhB,GADFD,IACEA,EAAK,GAAA,CACPF,EAAA,OAAA,MAAA,uDAAA,EACA,MACF,CACF,GAAA,CAAA,IAAAI,EAAAH,EAAA,UAAAV,EAAA,QAAA,EAAAa,IAAA,QAAAC,EAAA,WAAAF,EAAA,CAAA,EAAAC,aAAAE,GAOS,KAAA,KAA8BF,CAAA,CAEnC,OAAIG,EAAU,CACZP,EAAa,OAAA,MAAA,sCAAAO,CAAA,EACfF,EAAA,WAAAF,EAAA,CAAA,CACF,CACF,EAAAA,EAAA,CAAA,CAAA,EAAAF,EAAA,YAAA,YAAA,UAAAV,GAAA,CAKA,KAAA,SAA6BL,GAAA,CAAAD,EAAAC,CAAA,GAAAA,EAAA,KAAAK,EAAA,QAAA,CAC3B,CAAA,EACF,MAAA,MAAA,CAAA,CAAA,QAAAE,EAAA,CAAA,IAAAC,EAAAD,EAAA,OAAAE,GAAAV,EAAAU,CAAA,GAAA,CAAA,KAAA,MAAA,KAAAC,GAAA,KAAA,gBAAAA,EAAAD,CAAA,CAAA,CAAA,EAKA,OAAQ,MAAA,KAAA,GAAAD,CAAA,CACN,CACA,WAAKD,EAAA,CACL,IAAKC,EAAYD,EAAA,OAAAE,GAAAV,EAAAU,CAAA,GAAA,CAAA,KAAA,MAAA,KAAAC,GAAA,KAAA,gBAAAA,EAAAD,CAAA,CAAA,CAAA,EACjB,OAAK,MAAQa,QAAO,GAAAd,CAAA,CACtB,CAAA,OAAAG,EAAAC,KAAAL,EAAA,CAAA,GAAAK,IAAA,OAAA,OAAA,MAAA,OAAAD,CAAA,EAME,IAAIH,EAAKD,EAAU,OAAWE,GAAA,CAAA,KAAA,MAAA,KAAAC,GAAA,KAAA,gBAAAA,EAAAD,CAAA,CAAA,CAAA,EAC5B,OAAAa,MAAO,OAASX,EAAKC,EAAK,GAAAJ,CAAA,CAC1B,CAAa,EIzBf,IAAAe,GAAa,KAAO,iCC9ExB,CAAAC,EAAA,EAAA,EAAAA,EAAA,KAGE,CAAAA,EAAA,KAAA,EAAAA,EAAA,MAAA,CAAAA,EAGK,KAAA,EAAAA,EAAA,MAEK,CAAAA,EAAA,IAAA,EAALA,EAAA,KACLC,CAAAA,EAAAA,IAAA,EAAAD,EAAW,IACXC,EAEU,OAAA,uBAAL,CACLC,CAAAA,EAAAA,IAAA,EAAA,CACAA,EAAAA,KAFUF,EAAAE,KAAA,EAIA,CAAAF,EAAA,EAAA,EAAL,CACLG,EAAA,KACAA,EAAA,KACAA,EACAA,CAAAA,EAAA,KAAA,EAAA,CACAA,EAAA,KACAA,EAAA,EACAA,EACAA,CAAAA,EAAA,KAAA,EAAA,CACAA,EAAA,KACAA,EAAA,EACAA,EACAA,CAAAA,EAAA,IAAA,EAAA,CACAA,EAAA,MACAA,EAAA,EAdU,EAAA,CAAAH,EAAA,IAAA,EAAA,CA4CCA,EAAA,MAAaA,EAAA,EAAA,CAAA,EAAA,OAAA,uBAAA,CAAA,CAAAA,EAAA,IAAA,EAAA,CAAAA,EAAA,KASxBA,EAAc,KAKZ,EAAwB,CAAAA,EACtB,EAAA,EAAe,CAGfA,EAAA,KACFA,EAAA,KACF,EAAA,CAAAA,EAAA,KAAA,EAAA,CAAAA,EAAA,KAAAA,EAAA,IAAA,EAAA,CAAAA,EAAA,KAAA,EAAA,CAAAA,EAAA,KAAAA,EAAA,IAQA,EAME,CAAAA,EAAO,IAAA,EAAA,CACLA,EAAA,MAAwDA,EACtD,IAAA,EAEJ,CAAAA,EAAA,IAAA,EAAA,CACFA,EAAA,MAAAA,EAAA,IAAA,CAAA,EAME,OAAO,OAAW,CACpBA,EAAA,KAAAA,EAAA,GAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,KAAAA,EAAA,IAMA,CACE,EEnGiD,IACjDI,GAAuBC,EAAA,UAAA,YAAuB,gBAAA,WAAA,EpBZlD,IAAMC,EAAMC,EAAO,UAAU,YAAA,EAE7BC,EAAM,YAAY,iBAAiB,UAAWC,GAAA,CAC1CH,EAAI,KAAK,SAAUG,EAAM,MAAM,MAAM,CACzC,CAAA",
  "names": ["world", "Direction", "system2", "BlockPermutation", "world2", "world3", "Player", "system3", "system4", "system5", "world4", "Player2", "system6", "world5", "InputPermissionCategory", "system7", "Direction2", "StructureSaveMode", "world6", "EntityEquippableComponent", "EquipmentSlot", "ItemDurabilityComponent", "ItemEnchantableComponent", "code", "color", "_ChatColor", "str", "r", "g", "b", "minDistance", "closestColor", "distance", "ColorJSON", "_ColorJSON", "ChatColor", "plain", "value", "ctx", "indentSpace", "result", "compactResult", "item", "index", "className", "entries", "prefix", "key", "val", "compactVal", "name", "keySet", "prototype", "keys", "sourceMapping", "LogLevel", "_LogLevel", "level", "name", "color", "ChatColor", "str", "num", "OutputType", "starMatch", "pattern", "loggingSettings", "logger", "message", "tags", "_tags", "tag", "messages", "ColorJSON", "Logger", "_Logger", "system", "ev", "world", "filter", "func", "visible", "formatter", "x", "stack", "sourceMapping", "stackLineRegex", "line", "match", "filePath", "lineNumber", "mappingEntry", "replacement", "msgs", "formatted", "outputs", "Vec3", "_Vec3", "Direction", "y", "z", "yawOrRotation", "pitch", "yaw", "psi", "theta", "direction", "v", "scalar", "len", "t", "dot", "relative", "dotProduct", "lenSq1", "lenSq2", "denom", "cosAngle", "scale", "normal", "proj", "axis", "angle", "halfAngle", "w", "qv_x", "qv_y", "qv_z", "value", "start", "end", "lineDirection", "projection", "normalized", "maxValue", "delta", "other", "format", "separator", "result", "components", "Timings", "_Timings", "operation", "time", "isValid", "entity", "f", "log", "Logger", "PulseScheduler", "_PulseScheduler", "Logger", "processor", "period", "item", "items", "index", "predicate", "i", "system4", "totalExecutions", "interval", "world", "scheduledExecutions", "executed", "e", "system", "start", "deleteCount", "removed", "EntityPulseScheduler", "_EntityPulseScheduler", "PulseScheduler", "processor", "period", "queryOptions", "t", "isValid", "entity", "world4", "Logger", "a", "b", "event", "system5", "items", "filtered", "item", "existingItem", "start", "deleteCount", "PlayerPulseScheduler", "_PlayerPulseScheduler", "world5", "attempts", "pushPlayer", "player", "system6", "Player2", "e", "system", "DirectionUtils", "Direction2", "InputPermission", "CameraShakeType", "SlotLocation", "log2", "Logger", "log", "Logger", "world", "event"]
}
